// Code generated by tygo. DO NOT EDIT.
// Auto-generated by tygo. Do not edit manually.
//////////
// source: account.go

export interface User {
  id: string;
  username: string;
  access_token: string;
  is_admin: boolean;
}
export interface LocalUser {
  id: string;
  username: string;
  email?: string;
}

//////////
// source: analytics.go

/**
 * RequestAnalyticsResponse represents analytics data for request performance
 */
export interface RequestAnalyticsResponse {
  id: number /* int64 */;
  tmdb_id: number /* int64 */;
  media_type: string;
  title: string;
  request_count?: number /* int64 */;
  last_requested?: string /* RFC3339 */;
  first_requested?: string /* RFC3339 */;
  avg_processing_time_seconds?: number /* int64 */;
  success_rate?: number /* float64 */;
  popularity_score?: number /* float64 */;
  created_at?: string /* RFC3339 */;
  updated_at?: string /* RFC3339 */;
}
/**
 * RequestMetricResponse represents metrics for individual request tracking
 */
export interface RequestMetricResponse {
  id: number /* int64 */;
  request_id: number /* int64 */;
  status_change: string;
  previous_status?: string;
  new_status: string;
  processing_time_seconds?: number /* int64 */;
  error_code?: number /* int64 */;
  error_message?: string;
  user_id: string;
  timestamp?: string /* RFC3339 */;
}
/**
 * DriveUsageHistoryResponse represents drive usage tracking data
 */
export interface DriveUsageHistoryResponse {
  id: number /* int64 */;
  drive_id: string;
  total_size: number /* int64 */;
  used_size: number /* int64 */;
  available_size: number /* int64 */;
  usage_percentage: number /* float64 */;
  growth_rate_gb_per_day?: number /* float64 */;
  projected_full_date?: string /* RFC3339 */;
  recorded_at?: string /* RFC3339 */;
}
/**
 * DriveAlertResponse represents drive alert information
 */
export interface DriveAlertResponse {
  id: number /* int64 */;
  drive_id: string;
  alert_type: string;
  threshold_value: number /* float64 */;
  current_value: number /* float64 */;
  alert_message: string;
  is_active?: boolean;
  last_triggered?: string /* RFC3339 */;
  acknowledgement_count?: number /* int64 */;
  created_at?: string /* RFC3339 */;
}
/**
 * SystemMetricResponse represents system performance metrics
 */
export interface SystemMetricResponse {
  id: number /* int64 */;
  metric_type: string;
  metric_name: string;
  metric_value: number /* float64 */;
  metadata?: string;
  recorded_at?: string /* RFC3339 */;
}
/**
 * PopularityTrendResponse represents content popularity trend data
 */
export interface PopularityTrendResponse {
  id: number /* int64 */;
  tmdb_id: number /* int64 */;
  media_type: string;
  title: string;
  trend_source: string;
  popularity_score: number /* float64 */;
  trend_direction?: string;
  forecast_confidence?: number /* float64 */;
  metadata?: string;
  valid_until?: string /* RFC3339 */;
  created_at?: string /* RFC3339 */;
}
/**
 * RequestProcessingPerformanceResponse represents processing performance by media type and status
 */
export interface RequestProcessingPerformanceResponse {
  media_type: string;
  status: string;
  count: number /* int64 */;
}
/**
 * RequestSuccessRatesResponse represents success rates by status
 */
export interface RequestSuccessRatesResponse {
  status: string;
  total_requests: number /* int64 */;
  percentage: number /* float64 */;
}
/**
 * RequestTrendsResponse represents request trends over time
 */
export interface RequestTrendsResponse {
  request_date: any;
  total_requests: number /* int64 */;
  approved_requests: number /* int64 */;
  completed_requests: number /* int64 */;
  failed_requests: number /* int64 */;
  movie_requests: number /* int64 */;
  tv_requests: number /* int64 */;
}
/**
 * RequestVolumeByHourResponse represents request volume patterns by hour
 */
export interface RequestVolumeByHourResponse {
  hour_of_day: any;
  total_requests: number /* int64 */;
  successful_requests: number /* int64 */;
  success_rate: number /* float64 */;
}
/**
 * PopularRequestedContentResponse represents most requested content
 */
export interface PopularRequestedContentResponse {
  tmdb_id?: number /* int64 */;
  title?: string;
  media_type: string;
  request_count: number /* int64 */;
  fulfilled_count: number /* int64 */;
  failed_count: number /* int64 */;
  fulfillment_rate: number /* float64 */;
  first_requested: any;
  last_requested: any;
}
/**
 * RequestFulfillmentByUserResponse represents fulfillment metrics per user
 */
export interface RequestFulfillmentByUserResponse {
  username: string;
  total_requests: number /* int64 */;
  approved_requests: number /* int64 */;
  completed_requests: number /* int64 */;
  failed_requests: number /* int64 */;
  success_rate: number /* float64 */;
}
/**
 * FailureAnalysisResponse represents analysis of failed requests
 */
export interface FailureAnalysisResponse {
  media_type: string;
  total_failures: number /* int64 */;
  not_found_failures: number /* int64 */;
  connection_failures: number /* int64 */;
  quality_failures: number /* int64 */;
  storage_failures: number /* int64 */;
}
/**
 * ContentAvailabilityVsRequestsResponse represents content popularity vs availability
 */
export interface ContentAvailabilityVsRequestsResponse {
  tmdb_id?: number /* int64 */;
  title?: string;
  media_type: string;
  request_count: number /* int64 */;
  last_requested: any;
  is_available: any;
  fulfilled_requests: number /* int64 */;
}
/**
 * LatestDriveUsageResponse represents latest drive usage with drive info
 */
export interface LatestDriveUsageResponse {
  id: number /* int64 */;
  drive_id: string;
  total_size: number /* int64 */;
  used_size: number /* int64 */;
  available_size: number /* int64 */;
  usage_percentage: number /* float64 */;
  growth_rate_gb_per_day?: number /* float64 */;
  projected_full_date?: string /* RFC3339 */;
  recorded_at?: string /* RFC3339 */;
  drive_name: string;
  drive_mount_path: string;
}
/**
 * DriveGrowthPredictionResponse represents drive growth predictions
 */
export interface DriveGrowthPredictionResponse {
  drive_id: string;
  avg_growth_rate_gb_per_day?: number /* float64 */;
  current_avg_usage?: number /* float64 */;
  earliest_full_date: any;
}
/**
 * ActiveDriveAlertsResponse represents active drive alerts with drive info
 */
export interface ActiveDriveAlertsResponse {
  id: number /* int64 */;
  drive_id: string;
  alert_type: string;
  threshold_value: number /* float64 */;
  current_value: number /* float64 */;
  alert_message: string;
  is_active?: boolean;
  last_triggered?: string /* RFC3339 */;
  acknowledgement_count?: number /* int64 */;
  created_at?: string /* RFC3339 */;
  drive_name: string;
  mount_path: string;
}
/**
 * RequestSuccessRateAggregateResponse represents overall success rate metrics
 */
export interface RequestSuccessRateAggregateResponse {
  total_requests: number /* int64 */;
  fulfilled_requests?: number /* float64 */;
  success_rate: number /* int64 */;
}
/**
 * MostRequestedContentResponse represents most requested content with metrics
 */
export interface MostRequestedContentResponse {
  tmdb_id: number /* int64 */;
  media_type: string;
  title: string;
  request_count?: number /* int64 */;
  last_requested?: string /* RFC3339 */;
  popularity_score?: number /* float64 */;
}

//////////
// source: calendar.go

export interface CalendarItem {
  title: string;
  source: ArrProvider; // "radarr" or "sonarr"
  releaseDate: string /* RFC3339 */;
  tmdb_id: number /* int64 */;
}

//////////
// source: downloads.go

export interface Download {
  id: string;
  title: string;
  torrent_title: string;
  source: string;
  tmdb_id?: number /* int64 */;
  tvdb_id?: number /* int64 */;
  hash?: string;
  progress: number /* float64 */;
  time_left?: string;
  status?: string;
  update_at?: string;
  download_speed?: number /* int64 */; // bytes per second
  upload_speed?: number /* int64 */; // bytes per second
  download_size?: number /* int64 */; // total download size in bytes
}

//////////
// source: emby.go

export interface EmbyMediaItem {
  id: string;
  name: string;
  original_title?: string;
  type: string;
  parent_id?: string;
  series_id?: string;
  season_number?: number /* int */;
  episode_number?: number /* int */;
  year?: number /* int */;
  premiere_date?: string;
  end_date?: string;
  community_rating?: number /* float64 */;
  critic_rating?: number /* float64 */;
  official_rating?: string;
  overview?: string;
  tagline?: string;
  genres?: string[];
  studios?: string[];
  people?: EmbyPerson[];
  tmdb_id?: string;
  imdb_id?: string;
  tvdb_id?: string;
  musicbrainz_id?: string;
  path?: string;
  container?: string;
  size_bytes?: number /* int64 */;
  bitrate?: number /* int */;
  width?: number /* int */;
  height?: number /* int */;
  aspect_ratio?: string;
  video_codec?: string;
  audio_codec?: string;
  subtitle_tracks?: EmbyMediaTrack[];
  audio_tracks?: EmbyMediaTrack[];
  runtime_ticks?: number /* int64 */;
  runtime_minutes?: number /* int */;
  is_folder?: boolean;
  is_resumable?: boolean;
  play_count?: number /* int */;
  date_created?: string;
  date_modified?: string;
  last_played_date?: string;
  user_data?: { [key: string]: any};
  chapter_images_extracted?: boolean;
  primary_image_tag?: string;
  backdrop_image_tags?: string[];
  logo_image_tag?: string;
  art_image_tag?: string;
  thumb_image_tag?: string;
  is_hd?: boolean;
  is_4k?: boolean;
  is_3d?: boolean;
  locked?: boolean;
  provider_ids?: { [key: string]: string};
  external_urls?: { [key: string]: string};
  tags?: string[];
  sort_name?: string;
  forced_sort_name?: string;
  /**
   * Legacy fields for backwards compatibility
   */
  poster?: string;
}
export interface EmbyPerson {
  name: string;
  role: string;
  type: string; // Actor, Director, Producer, etc.
}
export interface EmbyMediaTrack {
  index: number /* int */;
  language?: string;
  codec?: string;
  title?: string;
  is_default?: boolean;
  is_forced?: boolean;
}

//////////
// source: jellystat.go

export interface JellystatLibrary {
  id: string;
  name: string;
  collection_type: string;
  library_count: number /* int */;
  season_count: number /* int */;
  episode_count: number /* int */;
}
export interface JellystatUserActivity {
  user_id: string;
  user_name: string;
  total_plays: number /* int */;
  total_watch_time: number /* int */;
}
export interface JellystatPopularContent {
  item_id: string;
  item_name: string;
  item_type: string;
  total_plays: number /* int */;
  total_runtime: number /* int */;
  average_rating: number /* float64 */;
  library_name: string;
}
export interface JellystatRecentlyWatched {
  item_id: string;
  item_name: string;
  item_type: string;
  user_name: string;
  play_duration: number /* int */;
  watched_at: string;
  library_name: string;
}
export interface JellystatWatchHistory {
  user_id: string;
  user_name: string;
  item_id: string;
  item_name: string;
  item_type: string;
  play_duration: number /* int */;
  watched_at: string;
  is_completed: boolean;
}
export interface JellystatActiveUser {
  user_id: string;
  user_name: string;
  plays: number /* int */;
}
export interface JellystatPlaybackMethod {
  name: string;
  count: number /* int */;
}

//////////
// source: jobs.go

export type Job = string;
export const JobDownloadPoller: Job = "download_poller";
export const JobDriveMonitor: Job = "drive_monitor";
export const JobRequestProcessor: Job = "request_processor";
export const JobLibrarySyncFull: Job = "library_sync_full";
export const JobLibrarySyncIncremental: Job = "library_sync_incremental";

//////////
// source: mounted_drives.go

/**
 * MountedDrive represents a mounted filesystem drive
 */
export interface MountedDrive {
  id: string;
  name: string;
  mount_path: string;
  filesystem?: string;
  total_size?: number /* int64 */;
  used_size?: number /* int64 */;
  available_size?: number /* int64 */;
  usage_percentage?: number /* float64 */;
  is_online: boolean;
  last_checked: string /* RFC3339 */;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
}
/**
 * CreateMountedDriveRequest represents a request to create a new mounted drive
 */
export interface CreateMountedDriveRequest {
  name: string;
  mount_path: string;
}
/**
 * UpdateMountedDriveRequest represents a request to update a mounted drive
 */
export interface UpdateMountedDriveRequest {
  name: string;
  mount_path: string;
}
/**
 * DriveStats represents the current statistics of a drive
 */
export interface DriveStats {
  total_size: number /* int64 */;
  used_size: number /* int64 */;
  available_size: number /* int64 */;
  usage_percentage: number /* float64 */;
  is_online: boolean;
}
/**
 * DriveStatsPayload represents the WebSocket payload for drive statistics updates
 */
export interface DriveStatsPayload {
  id: string;
  name: string;
  mount_path: string;
  stats: DriveStats;
  last_checked: string /* RFC3339 */;
}
/**
 * UpdateDriveThresholdsRequest represents a request to update drive monitoring thresholds
 */
export interface UpdateDriveThresholdsRequest {
  monitoring_enabled?: boolean;
  warning_threshold?: number /* float64 */;
  critical_threshold?: number /* float64 */;
  growth_rate_threshold?: number /* float64 */;
}
/**
 * DriveThresholds represents the current threshold configuration for a drive
 */
export interface DriveThresholds {
  drive_id: string;
  monitoring_enabled: boolean;
  warning_threshold: number /* float64 */;
  critical_threshold: number /* float64 */;
  growth_rate_threshold: number /* float64 */;
}
/**
 * StoragePool represents a storage pool (ZFS, UnRAID, etc.)
 */
export interface StoragePool {
  name: string;
  type: string; // "zfs", "unraid", "raid", "lvm"
  health: string;
  status: string;
  total_size: number /* int64 */;
  used_size: number /* int64 */;
  available_size: number /* int64 */;
  usage_percentage: number /* float64 */;
  redundancy?: string;
  devices?: StoragePoolDevice[];
  properties?: { [key: string]: any};
  last_checked: string /* RFC3339 */;
}
/**
 * StoragePoolDevice represents a device within a storage pool
 */
export interface StoragePoolDevice {
  name: string;
  path: string;
  status: string;
  health?: string;
  size?: number /* int64 */;
  read_errors?: number /* int64 */;
  write_errors?: number /* int64 */;
  checksum_errors?: number /* int64 */;
}
/**
 * ZFSPool represents a ZFS pool with specific ZFS properties
 */
export interface ZFSPool {
  StoragePool: StoragePool;
  compression?: string;
  deduplication?: string;
  scrub_status?: string;
  scrub_progress?: number /* float64 */;
  fragmentation_pct?: number /* float64 */;
}
/**
 * UnRAIDArray represents an UnRAID array
 */
export interface UnRAIDArray {
  StoragePool: StoragePool;
  parity_devices?: StoragePoolDevice[];
  data_devices?: StoragePoolDevice[];
  cache_devices?: StoragePoolDevice[];
  sync_status?: string;
  sync_progress?: number /* float64 */;
}

//////////
// source: permissions.go

/**
 * AssignPermissionRequest represents a request to assign a permission to a user
 */
export interface AssignPermissionRequest {
  permission: string;
}
/**
 * BulkUpdatePermissionsRequest represents a request to update all permissions for a user
 */
export interface BulkUpdatePermissionsRequest {
  permissions: string[];
}
/**
 * UserPermissionResponse represents a user's permission information
 */
export interface UserPermissionResponse {
  user_id: string;
  username: string;
  permissions: PermissionInfo[];
}
/**
 * PermissionInfo represents detailed permission information for API responses
 */
export interface PermissionInfo {
  id: string;
  name: string;
  description: string;
  category: string;
  dangerous: boolean;
}
/**
 * PermissionsListResponse represents the response for listing all permissions
 */
export interface PermissionsListResponse {
  permissions: PermissionInfo[];
  categories: { [key: string]: string[]};
}
/**
 * UserPermissionsUpdateLog represents an audit log entry for permission changes
 */
export interface UserPermissionsUpdateLog {
  user_id: string;
  updated_by: string;
  added: string[];
  removed: string[];
  timestamp: number /* int64 */;
}
/**
 * UserWithPermissions represents a user with their assigned permissions
 */
export interface UserWithPermissions {
  id: string;
  username: string;
  email: string;
  avatar_url?: string;
  user_type: string;
  created_at?: string;
  permissions: PermissionInfo[];
}

//////////
// source: provider.go

export type Provider = string;
export const ProviderEmby: Provider = "emby";
export const ProviderJellyfin: Provider = "jellyfin";
export type ArrProvider = string;
export const ProviderRadarr: ArrProvider = "radarr";
export const ProviderSonarr: ArrProvider = "sonarr";

//////////
// source: radarr.go

export interface RadarrQualityProfile {
  id: number /* int */;
  name: string;
  upgrade_allowed: boolean;
  cutoff: number /* int */;
  items: RadarrQualityProfileItem[];
  min_format_score: number /* int */;
  cutoff_format_score: number /* int */;
  min_upgrade_format_score: number /* int */;
  format_items: RadarrFormatItem[];
  language: RadarrLanguage;
}
export interface RadarrQualityProfileItem {
  quality: RadarrQuality;
  items: RadarrQualityProfileItem[];
  allowed: boolean;
  name?: string; // Only present for grouped items
  id?: number /* int */; // Only present for grouped items
}
export interface RadarrQuality {
  id: number /* int */;
  name: string;
  source: string;
  resolution: number /* int */;
  modifier: string;
}
export interface RadarrFormatItem {
  format: number /* int */;
  name: string;
  score: number /* int */;
}
export interface RadarrLanguage {
  id: number /* int */;
  name: string;
}
export interface RadarrRootFolder {
  path: string;
  accessible: boolean;
  free_space: number /* int64 */;
  unmapped_folders?: RadarrUnmappedFolder[];
}
export interface RadarrUnmappedFolder {
  name: string;
  path: string;
  relative_path: string;
}

//////////
// source: requests.go

/**
 * Request represents a media request made by a user
 */
export interface Request {
  id: number /* int64 */;
  user_id: string;
  username?: string;
  media_type: string;
  tmdb_id?: number /* int64 */;
  title: string;
  status: string;
  notes?: string;
  created_at: string;
  updated_at: string;
  fulfilled_at?: string;
  approver_id?: string;
  on_behalf_of?: string;
  poster_url?: string;
  seasons?: number /* int */[]; // For TV shows - which seasons were requested
  season_statuses?: { [key: string]: SeasonInfo}; // Status of each season
}
/**
 * CreateRequestRequest represents a request to create a new media request
 */
export interface CreateRequestRequest {
  media_type: string;
  tmdb_id: number /* int64 */;
  title: string;
  notes?: string;
  poster_url?: string;
  on_behalf_of?: string;
  seasons?: number /* int */[]; // For TV shows - which seasons to request
}
/**
 * UpdateRequestRequest represents a request to update an existing media request
 */
export interface UpdateRequestRequest {
  status: string;
  notes?: string;
}
/**
 * RequestStatistics represents statistics about requests in the system
 */
export interface RequestStatistics {
  total_requests: number /* int64 */;
  pending_requests: number /* int64 */;
  approved_requests: number /* int64 */;
  denied_requests: number /* int64 */;
  fulfilled_requests: number /* int64 */;
}
/**
 * GetAllRequestsResponse represents the response for getting all requests
 */
export interface GetAllRequestsResponse {
  total: number /* int64 */;
  requests: Request[];
}
/**
 * SeasonInfo represents the status of a specific season
 */
export interface SeasonInfo {
  status: string; // "pending", "approved", "fulfilled", "partial"
  episodes: string; // "available/total" e.g., "10/10" or "5/12"
  available_episodes: number /* int */; // Number of episodes available
  total_episodes: number /* int */; // Total episodes in season
  last_updated: string; // When status was last updated
}
/**
 * SeasonAvailability represents what's available in the media server
 */
export interface SeasonAvailability {
  id: number /* int */;
  tmdb_id: number /* int */;
  season_number: number /* int */;
  episode_count: number /* int */;
  available_episodes: number /* int */;
  is_complete: boolean;
  last_updated: string;
}
/**
 * ShowAvailability represents the overall availability of a TV show
 */
export interface ShowAvailability {
  tmdb_id: number /* int */;
  title: string;
  total_seasons: number /* int */;
  seasons: SeasonAvailability[];
  overall_status: string; // "not_available", "partial", "complete"
}
/**
 * SeasonRequest represents a request for specific seasons
 */
export interface SeasonRequest {
  tmdb_id: number /* int */;
  season_numbers: number /* int */[];
}
/**
 * SeasonStatusUpdate represents an update to season status
 */
export interface SeasonStatusUpdate {
  tmdb_id: number /* int */;
  season_number: number /* int */;
  status: string;
  available_episodes: number /* int */;
  total_episodes: number /* int */;
}

//////////
// source: respond.go

export interface APIErrorResponseBodyError {
  status_code: number /* int */;
  timestamp: number /* int */;
  error: APIError;
  trace_id?: string;
}
export interface APIError {
  status_code: number /* int */;
  message: string;
  error_code: number /* int */;
  details?: { [key: string]: any};
}

//////////
// source: settings.go

export type Setting = string;
export type RequestSystem = string;
/**
 * RequestSystemBuiltIn uses Serra's built-in request system
 */
export const RequestSystemBuiltIn: RequestSystem = "built_in";
/**
 * RequestSystemExternal uses an external request system (like Jellyseerr) in an iframe
 */
export const RequestSystemExternal: RequestSystem = "external";
export type DownloadVisibility = string;
/**
 * DownloadVisibilityAll allows all users to see all downloads
 */
export const DownloadVisibilityAll: DownloadVisibility = "all";
/**
 * DownloadVisibilityOwn allows users to see only their own downloads
 */
export const DownloadVisibilityOwn: DownloadVisibility = "own";
/**
 * SettingSetupComplete indicates that the initial setup has been completed.
 */
export const SettingSetupComplete: Setting = "setup_complete";
/**
 * SettingMediaServerType indicates the type of media server being used. Either "emby" or "jellyfin".
 */
export const SettingMediaServerType: Setting = "media_server_type";
/**
 * SettingMediaServerURL indicates the URL of the media server.
 */
export const SettingMediaServerURL: Setting = "media_server_url";
/**
 * SettingMediaServerAPIKey indicates the API key for the media server.
 */
export const SettingMediaServerAPIKey: Setting = "media_server_api_key";
/**
 * SettingRequestSystem indicates whether to use built-in request system or external system (like Jellyseerr)
 */
export const SettingRequestSystem: Setting = "request_system";
/**
 * SettingRequestSystemURL indicates the URL of the external request system (e.g., Jellyseerr)
 */
export const SettingRequestSystemURL: Setting = "request_system_url";
/**
 * SettingJellystatEnabled indicates whether Jellystat integration is enabled.
 */
export const SettingJellystatEnabled: Setting = "jellystat_enabled";
/**
 * SettingJellystatHost indicates the host/IP of the Jellystat service.
 */
export const SettingJellystatHost: Setting = "jellystat_host";
/**
 * SettingJellystatPort indicates the port of the Jellystat service.
 */
export const SettingJellystatPort: Setting = "jellystat_port";
/**
 * SettingJellystatUseSSL indicates whether to use HTTPS when connecting to Jellystat.
 */
export const SettingJellystatUseSSL: Setting = "jellystat_use_ssl";
/**
 * SettingJellystatURL indicates the URL of the Jellystat service.
 */
export const SettingJellystatURL: Setting = "jellystat_url";
/**
 * SettingJellystatAPIKey indicates the API key for the Jellystat service.
 */
export const SettingJellystatAPIKey: Setting = "jellystat_api_key";
/**
 * SettingDownloadVisibility controls whether users can see all downloads or only their own
 */
export const SettingDownloadVisibility: Setting = "download_visibility";
/**
 * SettingTMDBAPIKey indicates the API key for The Movie Database (TMDB) service
 */
export const SettingTMDBAPIKey: Setting = "tmdb_api_key";
/**
 * SettingEnableMediaServerAuth indicates whether users can authenticate using Emby/Jellyfin credentials
 */
export const SettingEnableMediaServerAuth: Setting = "enable_media_server_auth";
/**
 * SettingEnableLocalAuth indicates whether users can authenticate using local Serra accounts
 */
export const SettingEnableLocalAuth: Setting = "enable_local_auth";
/**
 * SettingEnableNewMediaServerAuth indicates whether new Emby/Jellyfin users can sign in without being imported first
 */
export const SettingEnableNewMediaServerAuth: Setting = "enable_new_media_server_auth";
/**
 * SettingGlobalMovieRequestLimit indicates the maximum number of movie requests per user (0 = unlimited)
 */
export const SettingGlobalMovieRequestLimit: Setting = "global_movie_request_limit";
/**
 * SettingGlobalSeriesRequestLimit indicates the maximum number of series requests per user (0 = unlimited)
 */
export const SettingGlobalSeriesRequestLimit: Setting = "global_series_request_limit";
/**
 * Default permission settings (individual booleans for each permission)
 * Owner permission
 */
export const SettingDefaultOwner: Setting = "default_owner";
/**
 * Admin permissions
 */
export const SettingDefaultAdminUsers: Setting = "default_admin_users";
export const SettingDefaultAdminServices: Setting = "default_admin_services";
export const SettingDefaultAdminSystem: Setting = "default_admin_system";
/**
 * Request permissions
 */
export const SettingDefaultRequestMovies: Setting = "default_request_movies";
export const SettingDefaultRequestSeries: Setting = "default_request_series";
export const SettingDefaultRequest4KMovies: Setting = "default_request_4k_movies";
export const SettingDefaultRequest4KSeries: Setting = "default_request_4k_series";
export const SettingDefaultRequestAutoApproveMovies: Setting = "default_request_auto_approve_movies";
export const SettingDefaultRequestAutoApproveSeries: Setting = "default_request_auto_approve_series";
export const SettingDefaultRequestAutoApprove4KMovies: Setting = "default_request_auto_approve_4k_movies";
export const SettingDefaultRequestAutoApprove4KSeries: Setting = "default_request_auto_approve_4k_series";
/**
 * Request management permissions
 */
export const SettingDefaultRequestsView: Setting = "default_requests_view";
export const SettingDefaultRequestsApprove: Setting = "default_requests_approve";
export const SettingDefaultRequestsManage: Setting = "default_requests_manage";

//////////
// source: sonarr.go

export interface SonarrQualityProfile {
  id: number /* int */;
  name: string;
  upgrade_allowed: boolean;
  cutoff: number /* int */;
  items: SonarrQualityProfileItem[];
  min_format_score: number /* int */;
  cutoff_format_score: number /* int */;
  min_upgrade_format_score: number /* int */;
  format_items: SonarrFormatItem[];
  language: SonarrLanguage;
}
export interface SonarrQualityProfileItem {
  quality: SonarrQuality;
  items: SonarrQualityProfileItem[];
  allowed: boolean;
  name?: string; // Only present for grouped items
  id?: number /* int */; // Only present for grouped items
}
export interface SonarrQuality {
  id: number /* int */;
  name: string;
  source: string;
  resolution: number /* int */;
  modifier: string;
}
export interface SonarrFormatItem {
  format: number /* int */;
  name: string;
  score: number /* int */;
}
export interface SonarrLanguage {
  id: number /* int */;
  name: string;
}
export interface SonarrRootFolder {
  path: string;
  accessible: boolean;
  free_space: number /* int64 */;
  unmapped_folders?: SonarrUnmappedFolder[];
}
export interface SonarrUnmappedFolder {
  name: string;
  path: string;
  relative_path: string;
}

//////////
// source: tmdb.go

export interface TMDBFullMediaResponse {
  TMDBPageResults: TMDBPageResults;
  results: TMDBFullMediaItem[];
}
export interface TMDBFullMediaItem {
  TMDBMediaItem: TMDBMediaItem;
  in_library: boolean;
  requested: boolean;
}
export interface TMDBPageResults {
  page: number /* int64 */;
  total_pages: number /* int64 */;
  total_results: number /* int64 */;
}
export interface TMDBMediaResponse {
  TMDBPageResults: TMDBPageResults;
  results: TMDBMediaItem[];
}
export interface TMDBMediaItem {
  adult?: boolean;
  gender?: number /* int */;
  backdrop_path?: string;
  genre_ids?: number /* int64 */[];
  id: number /* int64 */;
  original_language: string;
  original_title?: string;
  overview?: string;
  poster_path?: string;
  release_date?: string;
  title?: string;
  video?: boolean;
  vote_average?: number /* float32 */;
  vote_count?: number /* int64 */;
  popularity?: number /* float32 */;
  first_air_date?: string;
  name?: string;
  origin_country?: string[];
  original_name?: string;
  known_for_department?: string;
  profile_path?: string;
  media_type?: string;
  known_for?: {
    adult: boolean;
    backdrop_path: string;
    genre_ids: number /* int */[];
    id: number /* int */;
    original_language: string;
    original_title: string;
    overview: string;
    poster_path: string;
    release_date: string;
    title: string;
    video: boolean;
    vote_average: number /* float64 */;
    vote_count: number /* int */;
    popularity: number /* float64 */;
    media_type: string;
  }[];
}
export interface TVDetails {
  adult: boolean;
  backdrop_path: string;
  created_by: CreatedBy[];
  credits: Credits;
  episode_run_time: number /* int */[];
  first_air_date: string;
  genres: Genre[];
  homepage: string;
  id: number /* int */;
  in_production: boolean;
  languages: string[];
  last_air_date: string;
  last_episode_to_air: Episode;
  name: string;
  networks: Network[];
  next_episode_to_air: any;
  number_of_episodes: number /* int */;
  number_of_seasons: number /* int */;
  origin_country: string[];
  original_language: string;
  original_name: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  production_companies: ProductionCompany[];
  production_countries: ProductionCountry[];
  seasons: Season[];
  spoken_languages: SpokenLanguage[];
  status: string;
  tagline: string;
  type: string;
  videos: Videos;
  vote_average: number /* float64 */;
  vote_count: number /* int */;
}
export interface CreatedBy {
  credit_id: string;
  gender: number /* int */;
  id: number /* int */;
  name: string;
  original_name: string;
  profile_path: string;
}
export interface Credits {
  cast: CastMember[];
  crew: CrewMember[];
}
export interface CastMember {
  adult: boolean;
  character: string;
  credit_id: string;
  gender: number /* int */;
  id: number /* int */;
  known_for_department: string;
  name: string;
  order: number /* int */;
  original_name: string;
  popularity: number /* float64 */;
  profile_path: string;
}
export interface CrewMember {
  adult: boolean;
  credit_id: string;
  department: string;
  gender: number /* int */;
  id: number /* int */;
  job: string;
  known_for_department: string;
  name: string;
  original_name: string;
  popularity: number /* float64 */;
  profile_path: string;
}
export interface Genre {
  id: number /* int */;
  name: string;
}
export interface Network {
  id: number /* int */;
  logo_path: string;
  name: string;
  origin_country: string;
}
export interface ProductionCompany {
  id: number /* int */;
  logo_path: string;
  name: string;
  origin_country: string;
}
export interface ProductionCountry {
  iso_3166_1: string;
  name: string;
}
export interface Season {
  air_date: string;
  episode_count: number /* int */;
  id: number /* int */;
  name: string;
  overview: string;
  poster_path: string;
  season_number: number /* int */;
  vote_average: number /* float64 */;
}
export interface SpokenLanguage {
  english_name: string;
  iso_639_1: string;
  name: string;
}
export interface Episode {
  air_date: string;
  episode_number: number /* int */;
  episode_type: string;
  id: number /* int */;
  name: string;
  overview: string;
  production_code: string;
  runtime: number /* int */;
  season_number: number /* int */;
  show_id: number /* int */;
  still_path: string;
  vote_average: number /* float64 */;
  vote_count: number /* int */;
  crew: CrewMember[];
  guest_stars: CastMember[];
}
export interface Videos {
  results: Video[];
}
export interface Video {
  id: string;
  iso_3166_1: string;
  iso_639_1: string;
  key: string;
  name: string;
  official: boolean;
  published_at: string;
  site: string;
  size: number /* int */;
  type: string;
}
export interface MovieDetails {
  adult: boolean;
  backdrop_path: string;
  belongs_to_collection: any; // adjust if needed
  budget: number /* int64 */;
  genres: Genre[];
  homepage: string;
  id: number /* int64 */;
  imdb_id: string;
  origin_country: string[];
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  production_companies: Company[];
  production_countries: Country[];
  release_date: string;
  revenue: number /* int64 */;
  runtime: number /* int */;
  spoken_languages: Language[];
  status: string;
  tagline: string;
  title: string;
  video: boolean;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  videos: VideosResponse;
  credits: CreditsResponse;
}
export interface Company {
  id: number /* int64 */;
  logo_path?: string;
  name: string;
  origin_country: string;
}
export interface Country {
  iso_3166_1: string;
  name: string;
}
export interface Language {
  english_name: string;
  iso_639_1: string;
  name: string;
}
export interface VideosResponse {
  results: Video[];
}
export interface CreditsResponse {
  cast: CastMember[];
  crew: CrewMember[];
}
export interface SeasonDetails {
  _id: string;
  air_date: string;
  name: string;
  overview: string;
  id: number /* int */; // note: duplicated as both _id (string) and id (int)
  poster_path: string;
  season_number: number /* int */;
  vote_average: number /* float64 */;
  episodes: Episode[];
}
export interface TMDBWatchProvidersResponse {
  id: number /* int64 */;
  results: { [key: string]: TMDBCountryProviders};
}
export interface TMDBCountryProviders {
  link: string;
  rent?: TMDBProviderInfo[];
  buy?: TMDBProviderInfo[];
  flatrate?: TMDBProviderInfo[];
}
export interface TMDBProviderInfo {
  logo_path: string;
  provider_id: number /* int */;
  provider_name: string;
  display_priority: number /* int */;
}
export interface DiscoverMovieParams {
  Page: number /* int */;
  /**
   * Date range filters
   */
  ReleaseDateGTE: string; // Format: YYYY-MM-DD
  ReleaseDateLTE: string; // Format: YYYY-MM-DD
  /**
   * Studio/company filter
   */
  WithCompanies: string; // TMDB company ID(s), comma/pipe separated
  /**
   * Genres
   */
  WithGenres: string; // TMDB genre ID(s), comma/pipe separated
  /**
   * Keywords
   */
  WithKeywords: string; // TMDB keyword ID(s), comma/pipe separated
  /**
   * Language
   */
  WithOriginalLanguage: string; // ISO 639-1 code (e.g. "en", "fr")
  /**
   * Runtime
   */
  WithRuntimeGTE: number /* int */;
  WithRuntimeLTE: number /* int */;
  /**
   * TMDB user score (vote_average)
   */
  VoteAverageGTE: number /* float64 */;
  VoteAverageLTE: number /* float64 */;
  /**
   * TMDB user vote count
   */
  VoteCountGTE: number /* int */;
  VoteCountLTE: number /* int */;
  /**
   * Streaming services
   */
  WithWatchProviders: string; // Comma/pipe separated TMDB provider IDs
  WithWatchMonetizationTypes: string; // flatrate, free, ads, rent, buy
  WatchRegion: string; // e.g. "US", "GB"
  /**
   * Sorting (optional, but often useful)
   */
  SortBy: string;
}
export interface DiscoverTVParams {
  Page: number /* int */;
  /**
   * Date range filters for TV shows
   */
  AirDateGTE: string; // Format: YYYY-MM-DD
  AirDateLTE: string; // Format: YYYY-MM-DD
  FirstAirDateYear: number /* int */; // Year as integer
  FirstAirDateGTE: string; // Format: YYYY-MM-DD
  FirstAirDateLTE: string; // Format: YYYY-MM-DD
  /**
   * Content filters
   */
  IncludeAdult: boolean;
  IncludeNullFirstAirDates: boolean;
  Language: string; // Defaults to en-US
  ScreenedTheatrically: boolean;
  Timezone: string;
  /**
   * Rating filters
   */
  VoteAverageGTE: number /* float64 */;
  VoteAverageLTE: number /* float64 */;
  VoteCountGTE: number /* float64 */;
  VoteCountLTE: number /* float64 */;
  /**
   * Content categorization
   */
  WithGenres: string; // Comma (AND) or pipe (OR) separated
  WithKeywords: string; // Comma (AND) or pipe (OR) separated
  WithCompanies: string; // Comma (AND) or pipe (OR) separated
  WithNetworks: number /* int */; // TV network ID
  WithOriginCountry: string;
  WithOriginalLanguage: string; // ISO 639-1 code
  /**
   * Runtime filters
   */
  WithRuntimeGTE: number /* int */;
  WithRuntimeLTE: number /* int */;
  /**
   * Status filters
   */
  WithStatus: string; // 0,1,2,3,4,5 - comma (AND) or pipe (OR) separated
  /**
   * Watch providers
   */
  WatchRegion: string; // Use with watch providers
  WithWatchMonetizationTypes: string; // flatrate,free,ads,rent,buy
  WithWatchProviders: string; // Use with watch_region
  /**
   * Exclusion filters
   */
  WithoutCompanies: string;
  WithoutGenres: string;
  WithoutKeywords: string;
  WithoutWatchProviders: string;
  /**
   * Type filter
   */
  WithType: string; // 0,1,2,3,4,5,6 - comma (AND) or pipe (OR) separated
  /**
   * Sorting
   */
  SortBy: string; // Defaults to popularity.desc
}
/**
 * Watch providers list response
 */
export interface TMDBWatchProvidersListResponse {
  results: TMDBWatchProvider[];
}
export interface TMDBWatchProvider {
  display_priorities: { [key: string]: number /* int */};
  display_priority: number /* int */;
  logo_path: string;
  provider_name: string;
  provider_id: number /* int */;
}
/**
 * Watch provider regions response
 */
export interface TMDBWatchProviderRegionsResponse {
  results: TMDBWatchProviderRegion[];
}
export interface TMDBWatchProviderRegion {
  iso_3166_1: string;
  english_name: string;
  native_name: string;
}
/**
 * Company search response
 */
export interface TMDBCompanySearchResponse {
  TMDBPageResults: TMDBPageResults;
  results: TMDBCompany[];
}
export interface TMDBCompany {
  id: number /* int */;
  logo_path: string;
  name: string;
  origin_country: string;
}
/**
 * Release dates response
 */
export interface TMDBReleaseDatesResponse {
  id: number /* int */;
  results: TMDBCountryReleaseDate[];
}
export interface TMDBCountryReleaseDate {
  iso_3166_1: string;
  release_dates: TMDBReleaseDate[];
}
export interface TMDBReleaseDate {
  certification: string;
  release_date: string;
  type: number /* int */;
  note: string;
}
/**
 * Collection structures
 */
export interface TMDBCollectionResponse {
  id: number /* int64 */;
  name: string;
  overview: string;
  poster_path: string;
  backdrop_path: string;
  parts: TMDBMediaItem[];
}
export interface Collection {
  id: number /* int64 */;
  name: string;
  poster_path: string;
  backdrop_path: string;
}
/**
 * Person structures
 */
export interface TMDBPersonResponse {
  adult: boolean;
  also_known_as: string[];
  biography: string;
  birthday: string;
  deathday: string;
  gender: number /* int */;
  homepage: string;
  id: number /* int64 */;
  imdb_id: string;
  known_for_department: string;
  name: string;
  place_of_birth: string;
  popularity: number /* float64 */;
  profile_path: string;
  movie_credits: TMDBPersonMovieCredits;
  tv_credits: TMDBPersonTVCredits;
}
export interface TMDBPersonMovieCredits {
  cast: TMDBPersonMovieCast[];
  crew: TMDBPersonMovieCrew[];
}
export interface TMDBPersonTVCredits {
  cast: TMDBPersonTVCast[];
  crew: TMDBPersonTVCrew[];
}
export interface TMDBPersonMovieCast {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number /* int */[];
  id: number /* int64 */;
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  release_date: string;
  title: string;
  video: boolean;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  character: string;
  credit_id: string;
  order: number /* int */;
}
export interface TMDBPersonMovieCrew {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number /* int */[];
  id: number /* int64 */;
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  release_date: string;
  title: string;
  video: boolean;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  credit_id: string;
  department: string;
  job: string;
}
export interface TMDBPersonTVCast {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number /* int */[];
  id: number /* int64 */;
  origin_country: string[];
  original_language: string;
  original_name: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  first_air_date: string;
  name: string;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  character: string;
  credit_id: string;
  episode_count: number /* int */;
  first_credit_air_date: string;
}
export interface TMDBPersonTVCrew {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number /* int */[];
  id: number /* int64 */;
  origin_country: string[];
  original_language: string;
  original_name: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  first_air_date: string;
  name: string;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  credit_id: string;
  department: string;
  episode_count: number /* int */;
  first_credit_air_date: string;
  job: string;
}

//////////
// source: users.go

/**
 * User types
 */
export const UserTypeMediaServer = "media_server";
/**
 * User types
 */
export const UserTypeLocal = "local";
/**
 * LocalUserRegistrationRequest represents a request to create a local user
 */
export interface LocalUserRegistrationRequest {
  username: string;
  email: string;
  password: string;
  permissions: string[]; // Optional list of permissions to assign
}
/**
 * LocalUserLoginRequest represents a local user login request
 */
export interface LocalUserLoginRequest {
  username: string;
  password: string;
}
/**
 * ChangePasswordRequest represents a password change request for local users
 */
export interface ChangePasswordRequest {
  new_password: string;
}
export interface GetAllUsersResponse {
  total: number /* int64 */;
  users: UserWithPermissions[];
}

//////////
// source: websocket.go

export type Opcode = number /* uint8 */;
export const OpcodeDispatch: Opcode = 0; // Server sends event
export const OpcodeHello: Opcode = 1; // Server greets client
export const OpcodeHeartbeat: Opcode = 2; // Server/client keepalive
export const OpcodeReconnect: Opcode = 3; // Server requests reconnect
export const OpcodeAck: Opcode = 4; // Server acknowledges action
export const OpcodeError: Opcode = 5; // Server sends error
export const OpcodeDownloadProgress: Opcode = 10; // Server sends download progress
export const OpcodeDownloadRemoved: Opcode = 11; // Server notifies download removal
export const OpcodeDownloadProgressBatch: Opcode = 12; // Server sends batch download progress
export const OpcodeSystemStatus: Opcode = 13; // Server sends system status
export const OpcodeUserActivity: Opcode = 14; // Server sends user activity updates
export interface Message {
  op: Opcode; // Operation type
  t: number /* int64 */; // Millisecond timestamp
  d: any; // Any payload
  s?: number /* uint64 */; // Optional sequence number
}
/**
 * HelloPayload is sent when a client connects
 */
export interface HelloPayload {
  message: string;
  server_id?: string;
  features?: string[];
  metadata?: { [key: string]: string};
}
/**
 * ErrorPayload represents an error message
 */
export interface ErrorPayload {
  message: string;
  code?: string;
  request_id?: string;
}
/**
 * DownloadProgressPayload represents download progress
 */
export interface DownloadProgressPayload {
  id: string;
  title: string;
  torrent_title: string;
  source: string;
  tmdb_id?: number /* int64 */; // Optional TMDB ID
  tvdb_id?: number /* int64 */; // Optional TVDB ID
  hash: string;
  progress: number /* float64 */; // 0-100
  time_left: string;
  status: string;
  last_updated: string;
  download_speed?: number /* int64 */; // bytes per second
  download_size?: number /* int64 */; // total download size in bytes
}
/**
 * DownloadRemovedPayload represents a removed download
 */
export interface DownloadRemovedPayload {
  download_id: string;
  reason?: string;
}
/**
 * DownloadProgressBatchPayload represents multiple download updates
 */
export interface DownloadProgressBatchPayload {
  downloads: DownloadProgressPayload[];
  count: number /* int */;
  timestamp: number /* int64 */;
}
/**
 * MediaStatusResponse represents the status of a media item
 */
export interface MediaStatusResponse {
  tmdb_id: number;
  media_type: string;
  in_library: boolean;
  requested: boolean;
}
/**
 * SystemStatusPayload represents system status information
 */
export interface SystemStatusPayload {
  status: string; // "online", "maintenance", "error"
  uptime: number /* int64 */; // Server uptime in seconds
  connections: number /* int */; // Active WebSocket connections
  load?: { [key: string]: string}; // System load information
  memory?: { [key: string]: number /* int64 */}; // Memory usage
  disk?: { [key: string]: number /* int64 */}; // Disk usage
}
/**
 * UserActivityPayload represents user activity updates
 */
export interface UserActivityPayload {
  user_id: string;
  username: string;
  activity: string; // "login", "logout", "download_start", etc.
  timestamp: number /* int64 */;
  metadata?: { [key: string]: any};
}
