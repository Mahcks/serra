// Code generated by tygo. DO NOT EDIT.
// Auto-generated by tygo. Do not edit manually.
//////////
// source: account.go

export interface User {
  id: string;
  username: string;
  access_token: string;
  is_admin: boolean;
}
export interface LocalUser {
  id: string;
  username: string;
  email?: string;
}

//////////
// source: calendar.go

export interface CalendarItem {
  title: string;
  source: ArrProvider; // "radarr" or "sonarr"
  releaseDate: string /* RFC3339 */;
}

//////////
// source: downloads.go

export interface Download {
  id: string;
  title: string;
  torrent_title: string;
  source: string;
  tmdb_id?: number /* int64 */;
  tvdb_id?: number /* int64 */;
  hash?: string;
  progress: number /* float64 */;
  time_left?: string;
  status?: string;
  update_at?: string;
  download_speed?: number /* int64 */; // bytes per second
  upload_speed?: number /* int64 */; // bytes per second
  download_size?: number /* int64 */; // total download size in bytes
}

//////////
// source: emby.go

export interface EmbyMediaItem {
  id: string;
  name: string;
  original_title?: string;
  type: string;
  parent_id?: string;
  series_id?: string;
  season_number?: number /* int */;
  episode_number?: number /* int */;
  year?: number /* int */;
  premiere_date?: string;
  end_date?: string;
  community_rating?: number /* float64 */;
  critic_rating?: number /* float64 */;
  official_rating?: string;
  overview?: string;
  tagline?: string;
  genres?: string[];
  studios?: string[];
  people?: EmbyPerson[];
  tmdb_id?: string;
  imdb_id?: string;
  tvdb_id?: string;
  musicbrainz_id?: string;
  path?: string;
  container?: string;
  size_bytes?: number /* int64 */;
  bitrate?: number /* int */;
  width?: number /* int */;
  height?: number /* int */;
  aspect_ratio?: string;
  video_codec?: string;
  audio_codec?: string;
  subtitle_tracks?: EmbyMediaTrack[];
  audio_tracks?: EmbyMediaTrack[];
  runtime_ticks?: number /* int64 */;
  runtime_minutes?: number /* int */;
  is_folder?: boolean;
  is_resumable?: boolean;
  play_count?: number /* int */;
  date_created?: string;
  date_modified?: string;
  last_played_date?: string;
  user_data?: { [key: string]: any};
  chapter_images_extracted?: boolean;
  primary_image_tag?: string;
  backdrop_image_tags?: string[];
  logo_image_tag?: string;
  art_image_tag?: string;
  thumb_image_tag?: string;
  is_hd?: boolean;
  is_4k?: boolean;
  is_3d?: boolean;
  locked?: boolean;
  provider_ids?: { [key: string]: string};
  external_urls?: { [key: string]: string};
  tags?: string[];
  sort_name?: string;
  forced_sort_name?: string;
  /**
   * Legacy fields for backwards compatibility
   */
  poster?: string;
}
export interface EmbyPerson {
  name: string;
  role: string;
  type: string; // Actor, Director, Producer, etc.
}
export interface EmbyMediaTrack {
  index: number /* int */;
  language?: string;
  codec?: string;
  title?: string;
  is_default?: boolean;
  is_forced?: boolean;
}

//////////
// source: jellystat.go

export interface JellystatLibrary {
  id: string;
  name: string;
  collection_type: string;
  library_count: number /* int */;
  season_count: number /* int */;
  episode_count: number /* int */;
}
export interface JellystatUserActivity {
  user_id: string;
  user_name: string;
  total_plays: number /* int */;
  total_watch_time: number /* int */;
}

//////////
// source: jobs.go

export type Job = string;
export const JobDownloadPoller: Job = "download_poller";
export const JobDriveMonitor: Job = "drive_monitor";
export const JobRequestProcessor: Job = "request_processor";
export const JobLibrarySyncFull: Job = "library_sync_full";
export const JobLibrarySyncIncremental: Job = "library_sync_incremental";

//////////
// source: mounted_drives.go

/**
 * MountedDrive represents a mounted filesystem drive
 */
export interface MountedDrive {
  id: string;
  name: string;
  mount_path: string;
  filesystem?: string;
  total_size?: number /* int64 */;
  used_size?: number /* int64 */;
  available_size?: number /* int64 */;
  usage_percentage?: number /* float64 */;
  is_online: boolean;
  last_checked: string /* RFC3339 */;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
}
/**
 * CreateMountedDriveRequest represents a request to create a new mounted drive
 */
export interface CreateMountedDriveRequest {
  name: string;
  mount_path: string;
}
/**
 * UpdateMountedDriveRequest represents a request to update a mounted drive
 */
export interface UpdateMountedDriveRequest {
  name: string;
  mount_path: string;
}
/**
 * DriveStats represents the current statistics of a drive
 */
export interface DriveStats {
  total_size: number /* int64 */;
  used_size: number /* int64 */;
  available_size: number /* int64 */;
  usage_percentage: number /* float64 */;
  is_online: boolean;
}
/**
 * DriveStatsPayload represents the WebSocket payload for drive statistics updates
 */
export interface DriveStatsPayload {
  id: string;
  name: string;
  mount_path: string;
  stats: DriveStats;
  last_checked: string /* RFC3339 */;
}

//////////
// source: permissions.go

/**
 * AssignPermissionRequest represents a request to assign a permission to a user
 */
export interface AssignPermissionRequest {
  permission: string;
}
/**
 * BulkUpdatePermissionsRequest represents a request to update all permissions for a user
 */
export interface BulkUpdatePermissionsRequest {
  permissions: string[];
}
/**
 * UserPermissionResponse represents a user's permission information
 */
export interface UserPermissionResponse {
  user_id: string;
  username: string;
  permissions: PermissionInfo[];
}
/**
 * PermissionInfo represents detailed permission information for API responses
 */
export interface PermissionInfo {
  id: string;
  name: string;
  description: string;
  category: string;
  dangerous: boolean;
}
/**
 * PermissionsListResponse represents the response for listing all permissions
 */
export interface PermissionsListResponse {
  permissions: PermissionInfo[];
  categories: { [key: string]: string[]};
}
/**
 * UserPermissionsUpdateLog represents an audit log entry for permission changes
 */
export interface UserPermissionsUpdateLog {
  user_id: string;
  updated_by: string;
  added: string[];
  removed: string[];
  timestamp: number /* int64 */;
}
/**
 * UserWithPermissions represents a user with their assigned permissions
 */
export interface UserWithPermissions {
  id: string;
  username: string;
  email: string;
  avatar_url?: string;
  user_type: string;
  created_at?: string;
  permissions: PermissionInfo[];
}

//////////
// source: provider.go

export type Provider = string;
export const ProviderEmby: Provider = "emby";
export const ProviderJellyfin: Provider = "jellyfin";
export type ArrProvider = string;
export const ProviderRadarr: ArrProvider = "radarr";
export const ProviderSonarr: ArrProvider = "sonarr";

//////////
// source: radarr.go

export interface RadarrQualityProfile {
  id: number /* int */;
  name: string;
  upgrade_allowed: boolean;
  cutoff: number /* int */;
  items: RadarrQualityProfileItem[];
  min_format_score: number /* int */;
  cutoff_format_score: number /* int */;
  min_upgrade_format_score: number /* int */;
  format_items: RadarrFormatItem[];
  language: RadarrLanguage;
}
export interface RadarrQualityProfileItem {
  quality: RadarrQuality;
  items: RadarrQualityProfileItem[];
  allowed: boolean;
  name?: string; // Only present for grouped items
  id?: number /* int */; // Only present for grouped items
}
export interface RadarrQuality {
  id: number /* int */;
  name: string;
  source: string;
  resolution: number /* int */;
  modifier: string;
}
export interface RadarrFormatItem {
  format: number /* int */;
  name: string;
  score: number /* int */;
}
export interface RadarrLanguage {
  id: number /* int */;
  name: string;
}
export interface RadarrRootFolder {
  path: string;
  accessible: boolean;
  free_space: number /* int64 */;
  unmapped_folders?: RadarrUnmappedFolder[];
}
export interface RadarrUnmappedFolder {
  name: string;
  path: string;
  relative_path: string;
}

//////////
// source: requests.go

/**
 * Request represents a media request made by a user
 */
export interface Request {
  id: number /* int64 */;
  user_id: string;
  username?: string;
  media_type: string;
  tmdb_id?: number /* int64 */;
  title: string;
  status: string;
  notes?: string;
  created_at: string;
  updated_at: string;
  fulfilled_at?: string;
  approver_id?: string;
  on_behalf_of?: string;
  poster_url?: string;
}
/**
 * CreateRequestRequest represents a request to create a new media request
 */
export interface CreateRequestRequest {
  media_type: string;
  tmdb_id: number /* int64 */;
  title: string;
  notes?: string;
  poster_url?: string;
  on_behalf_of?: string;
}
/**
 * UpdateRequestRequest represents a request to update an existing media request
 */
export interface UpdateRequestRequest {
  status: string;
  notes?: string;
}
/**
 * RequestStatistics represents statistics about requests in the system
 */
export interface RequestStatistics {
  total_requests: number /* int64 */;
  pending_requests: number /* int64 */;
  approved_requests: number /* int64 */;
  denied_requests: number /* int64 */;
  fulfilled_requests: number /* int64 */;
}
/**
 * GetAllRequestsResponse represents the response for getting all requests
 */
export interface GetAllRequestsResponse {
  total: number /* int64 */;
  requests: Request[];
}

//////////
// source: respond.go

export interface APIErrorResponseBodyError {
  status_code: number /* int */;
  timestamp: number /* int */;
  error: APIError;
  trace_id?: string;
}
export interface APIError {
  status_code: number /* int */;
  message: string;
  error_code: number /* int */;
  details?: { [key: string]: any};
}

//////////
// source: settings.go

export type Setting = string;
export type RequestSystem = string;
/**
 * RequestSystemBuiltIn uses Serra's built-in request system
 */
export const RequestSystemBuiltIn: RequestSystem = "built_in";
/**
 * RequestSystemExternal uses an external request system (like Jellyseerr) in an iframe
 */
export const RequestSystemExternal: RequestSystem = "external";
export type DownloadVisibility = string;
/**
 * DownloadVisibilityAll allows all users to see all downloads
 */
export const DownloadVisibilityAll: DownloadVisibility = "all";
/**
 * DownloadVisibilityOwn allows users to see only their own downloads
 */
export const DownloadVisibilityOwn: DownloadVisibility = "own";
/**
 * SettingSetupComplete indicates that the initial setup has been completed.
 */
export const SettingSetupComplete: Setting = "setup_complete";
/**
 * SettingMediaServerType indicates the type of media server being used. Either "emby" or "jellyfin".
 */
export const SettingMediaServerType: Setting = "media_server_type";
/**
 * SettingMediaServerURL indicates the URL of the media server.
 */
export const SettingMediaServerURL: Setting = "media_server_url";
/**
 * SettingMediaServerAPIKey indicates the API key for the media server.
 */
export const SettingMediaServerAPIKey: Setting = "media_server_api_key";
/**
 * SettingRequestSystem indicates whether to use built-in request system or external system (like Jellyseerr)
 */
export const SettingRequestSystem: Setting = "request_system";
/**
 * SettingRequestSystemURL indicates the URL of the external request system (e.g., Jellyseerr)
 */
export const SettingRequestSystemURL: Setting = "request_system_url";
/**
 * SettingJellystatURL indicates the URL of the Jellystat service.
 */
export const SettingJellystatURL: Setting = "jellystat_url";
/**
 * SettingJellystatAPIKey indicates the API key for the Jellystat service.
 */
export const SettingJellystatAPIKey: Setting = "jellystat_api_key";
/**
 * SettingDownloadVisibility controls whether users can see all downloads or only their own
 */
export const SettingDownloadVisibility: Setting = "download_visibility";
/**
 * SettingTMDBAPIKey indicates the API key for The Movie Database (TMDB) service
 */
export const SettingTMDBAPIKey: Setting = "tmdb_api_key";

//////////
// source: sonarr.go

export interface SonarrQualityProfile {
  id: number /* int */;
  name: string;
  upgrade_allowed: boolean;
  cutoff: number /* int */;
  items: SonarrQualityProfileItem[];
  min_format_score: number /* int */;
  cutoff_format_score: number /* int */;
  min_upgrade_format_score: number /* int */;
  format_items: SonarrFormatItem[];
  language: SonarrLanguage;
}
export interface SonarrQualityProfileItem {
  quality: SonarrQuality;
  items: SonarrQualityProfileItem[];
  allowed: boolean;
  name?: string; // Only present for grouped items
  id?: number /* int */; // Only present for grouped items
}
export interface SonarrQuality {
  id: number /* int */;
  name: string;
  source: string;
  resolution: number /* int */;
  modifier: string;
}
export interface SonarrFormatItem {
  format: number /* int */;
  name: string;
  score: number /* int */;
}
export interface SonarrLanguage {
  id: number /* int */;
  name: string;
}
export interface SonarrRootFolder {
  path: string;
  accessible: boolean;
  free_space: number /* int64 */;
  unmapped_folders?: SonarrUnmappedFolder[];
}
export interface SonarrUnmappedFolder {
  name: string;
  path: string;
  relative_path: string;
}

//////////
// source: tmdb.go

export interface TMDBFullMediaResponse {
  TMDBPageResults: TMDBPageResults;
  results: TMDBFullMediaItem[];
}
export interface TMDBFullMediaItem {
  TMDBMediaItem: TMDBMediaItem;
  in_library: boolean;
  requested: boolean;
}
export interface TMDBPageResults {
  page: number /* int64 */;
  total_pages: number /* int64 */;
  total_results: number /* int64 */;
}
export interface TMDBMediaResponse {
  TMDBPageResults: TMDBPageResults;
  results: TMDBMediaItem[];
}
export interface TMDBMediaItem {
  adult?: boolean;
  gender?: number /* int */;
  backdrop_path?: string;
  genre_ids?: number /* int64 */[];
  id: number /* int64 */;
  original_language: string;
  original_title?: string;
  overview?: string;
  poster_path?: string;
  release_date?: string;
  title?: string;
  video?: boolean;
  vote_average?: number /* float32 */;
  vote_count?: number /* int64 */;
  popularity?: number /* float32 */;
  first_air_date?: string;
  name?: string;
  origin_country?: string[];
  original_name?: string;
  known_for_department?: string;
  profile_path?: string;
  media_type?: string;
  known_for?: {
    adult: boolean;
    backdrop_path: string;
    genre_ids: number /* int */[];
    id: number /* int */;
    original_language: string;
    original_title: string;
    overview: string;
    poster_path: string;
    release_date: string;
    title: string;
    video: boolean;
    vote_average: number /* float64 */;
    vote_count: number /* int */;
    popularity: number /* float64 */;
    media_type: string;
  }[];
}
export interface TVDetails {
  adult: boolean;
  backdrop_path: string;
  created_by: CreatedBy[];
  credits: Credits;
  episode_run_time: number /* int */[];
  first_air_date: string;
  genres: Genre[];
  homepage: string;
  id: number /* int */;
  in_production: boolean;
  languages: string[];
  last_air_date: string;
  last_episode_to_air: Episode;
  name: string;
  networks: Network[];
  next_episode_to_air: any;
  number_of_episodes: number /* int */;
  number_of_seasons: number /* int */;
  origin_country: string[];
  original_language: string;
  original_name: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  production_companies: ProductionCompany[];
  production_countries: ProductionCountry[];
  seasons: Season[];
  spoken_languages: SpokenLanguage[];
  status: string;
  tagline: string;
  type: string;
  videos: Videos;
  vote_average: number /* float64 */;
  vote_count: number /* int */;
}
export interface CreatedBy {
  credit_id: string;
  gender: number /* int */;
  id: number /* int */;
  name: string;
  original_name: string;
  profile_path: string;
}
export interface Credits {
  cast: CastMember[];
  crew: CrewMember[];
}
export interface CastMember {
  adult: boolean;
  character: string;
  credit_id: string;
  gender: number /* int */;
  id: number /* int */;
  known_for_department: string;
  name: string;
  order: number /* int */;
  original_name: string;
  popularity: number /* float64 */;
  profile_path: string;
}
export interface CrewMember {
  adult: boolean;
  credit_id: string;
  department: string;
  gender: number /* int */;
  id: number /* int */;
  job: string;
  known_for_department: string;
  name: string;
  original_name: string;
  popularity: number /* float64 */;
  profile_path: string;
}
export interface Genre {
  id: number /* int */;
  name: string;
}
export interface Network {
  id: number /* int */;
  logo_path: string;
  name: string;
  origin_country: string;
}
export interface ProductionCompany {
  id: number /* int */;
  logo_path: string;
  name: string;
  origin_country: string;
}
export interface ProductionCountry {
  iso_3166_1: string;
  name: string;
}
export interface Season {
  air_date: string;
  episode_count: number /* int */;
  id: number /* int */;
  name: string;
  overview: string;
  poster_path: string;
  season_number: number /* int */;
  vote_average: number /* float64 */;
}
export interface SpokenLanguage {
  english_name: string;
  iso_639_1: string;
  name: string;
}
export interface Episode {
  air_date: string;
  episode_number: number /* int */;
  episode_type: string;
  id: number /* int */;
  name: string;
  overview: string;
  production_code: string;
  runtime: number /* int */;
  season_number: number /* int */;
  show_id: number /* int */;
  still_path: string;
  vote_average: number /* float64 */;
  vote_count: number /* int */;
  crew: CrewMember[];
  guest_stars: CastMember[];
}
export interface Videos {
  results: Video[];
}
export interface Video {
  id: string;
  iso_3166_1: string;
  iso_639_1: string;
  key: string;
  name: string;
  official: boolean;
  published_at: string;
  site: string;
  size: number /* int */;
  type: string;
}
export interface MovieDetails {
  adult: boolean;
  backdrop_path: string;
  belongs_to_collection: any; // adjust if needed
  budget: number /* int64 */;
  genres: Genre[];
  homepage: string;
  id: number /* int64 */;
  imdb_id: string;
  origin_country: string[];
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  production_companies: Company[];
  production_countries: Country[];
  release_date: string;
  revenue: number /* int64 */;
  runtime: number /* int */;
  spoken_languages: Language[];
  status: string;
  tagline: string;
  title: string;
  video: boolean;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  videos: VideosResponse;
  credits: CreditsResponse;
}
export interface Company {
  id: number /* int64 */;
  logo_path?: string;
  name: string;
  origin_country: string;
}
export interface Country {
  iso_3166_1: string;
  name: string;
}
export interface Language {
  english_name: string;
  iso_639_1: string;
  name: string;
}
export interface VideosResponse {
  results: Video[];
}
export interface CreditsResponse {
  cast: CastMember[];
  crew: CrewMember[];
}
export interface SeasonDetails {
  _id: string;
  air_date: string;
  name: string;
  overview: string;
  id: number /* int */; // note: duplicated as both _id (string) and id (int)
  poster_path: string;
  season_number: number /* int */;
  vote_average: number /* float64 */;
  episodes: Episode[];
}
export interface TMDBWatchProvidersResponse {
  id: number /* int64 */;
  results: { [key: string]: TMDBCountryProviders};
}
export interface TMDBCountryProviders {
  link: string;
  rent?: TMDBProviderInfo[];
  buy?: TMDBProviderInfo[];
  flatrate?: TMDBProviderInfo[];
}
export interface TMDBProviderInfo {
  logo_path: string;
  provider_id: number /* int */;
  provider_name: string;
  display_priority: number /* int */;
}
export interface DiscoverMovieParams {
  Page: number /* int */;
  /**
   * Date range filters
   */
  ReleaseDateGTE: string; // Format: YYYY-MM-DD
  ReleaseDateLTE: string; // Format: YYYY-MM-DD
  /**
   * Studio/company filter
   */
  WithCompanies: string; // TMDB company ID(s), comma/pipe separated
  /**
   * Genres
   */
  WithGenres: string; // TMDB genre ID(s), comma/pipe separated
  /**
   * Keywords
   */
  WithKeywords: string; // TMDB keyword ID(s), comma/pipe separated
  /**
   * Language
   */
  WithOriginalLanguage: string; // ISO 639-1 code (e.g. "en", "fr")
  /**
   * Runtime
   */
  WithRuntimeGTE: number /* int */;
  WithRuntimeLTE: number /* int */;
  /**
   * TMDB user score (vote_average)
   */
  VoteAverageGTE: number /* float64 */;
  VoteAverageLTE: number /* float64 */;
  /**
   * TMDB user vote count
   */
  VoteCountGTE: number /* int */;
  VoteCountLTE: number /* int */;
  /**
   * Streaming services
   */
  WithWatchProviders: string; // Comma/pipe separated TMDB provider IDs
  WithWatchMonetizationTypes: string; // flatrate, free, ads, rent, buy
  WatchRegion: string; // e.g. "US", "GB"
  /**
   * Sorting (optional, but often useful)
   */
  SortBy: string;
}
/**
 * Watch providers list response
 */
export interface TMDBWatchProvidersListResponse {
  results: TMDBWatchProvider[];
}
export interface TMDBWatchProvider {
  display_priorities: { [key: string]: number /* int */};
  display_priority: number /* int */;
  logo_path: string;
  provider_name: string;
  provider_id: number /* int */;
}
/**
 * Watch provider regions response
 */
export interface TMDBWatchProviderRegionsResponse {
  results: TMDBWatchProviderRegion[];
}
export interface TMDBWatchProviderRegion {
  iso_3166_1: string;
  english_name: string;
  native_name: string;
}
/**
 * Company search response
 */
export interface TMDBCompanySearchResponse {
  TMDBPageResults: TMDBPageResults;
  results: TMDBCompany[];
}
export interface TMDBCompany {
  id: number /* int */;
  logo_path: string;
  name: string;
  origin_country: string;
}
/**
 * Release dates response
 */
export interface TMDBReleaseDatesResponse {
  id: number /* int */;
  results: TMDBCountryReleaseDate[];
}
export interface TMDBCountryReleaseDate {
  iso_3166_1: string;
  release_dates: TMDBReleaseDate[];
}
export interface TMDBReleaseDate {
  certification: string;
  release_date: string;
  type: number /* int */;
  note: string;
}
/**
 * Collection structures
 */
export interface TMDBCollectionResponse {
  id: number /* int64 */;
  name: string;
  overview: string;
  poster_path: string;
  backdrop_path: string;
  parts: TMDBMediaItem[];
}
export interface Collection {
  id: number /* int64 */;
  name: string;
  poster_path: string;
  backdrop_path: string;
}
/**
 * Person structures
 */
export interface TMDBPersonResponse {
  adult: boolean;
  also_known_as: string[];
  biography: string;
  birthday: string;
  deathday: string;
  gender: number /* int */;
  homepage: string;
  id: number /* int64 */;
  imdb_id: string;
  known_for_department: string;
  name: string;
  place_of_birth: string;
  popularity: number /* float64 */;
  profile_path: string;
  movie_credits: TMDBPersonMovieCredits;
  tv_credits: TMDBPersonTVCredits;
}
export interface TMDBPersonMovieCredits {
  cast: TMDBPersonMovieCast[];
  crew: TMDBPersonMovieCrew[];
}
export interface TMDBPersonTVCredits {
  cast: TMDBPersonTVCast[];
  crew: TMDBPersonTVCrew[];
}
export interface TMDBPersonMovieCast {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number /* int */[];
  id: number /* int64 */;
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  release_date: string;
  title: string;
  video: boolean;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  character: string;
  credit_id: string;
  order: number /* int */;
}
export interface TMDBPersonMovieCrew {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number /* int */[];
  id: number /* int64 */;
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  release_date: string;
  title: string;
  video: boolean;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  credit_id: string;
  department: string;
  job: string;
}
export interface TMDBPersonTVCast {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number /* int */[];
  id: number /* int64 */;
  origin_country: string[];
  original_language: string;
  original_name: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  first_air_date: string;
  name: string;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  character: string;
  credit_id: string;
  episode_count: number /* int */;
  first_credit_air_date: string;
}
export interface TMDBPersonTVCrew {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number /* int */[];
  id: number /* int64 */;
  origin_country: string[];
  original_language: string;
  original_name: string;
  overview: string;
  popularity: number /* float64 */;
  poster_path: string;
  first_air_date: string;
  name: string;
  vote_average: number /* float64 */;
  vote_count: number /* int64 */;
  credit_id: string;
  department: string;
  episode_count: number /* int */;
  first_credit_air_date: string;
  job: string;
}

//////////
// source: users.go

/**
 * User types
 */
export const UserTypeMediaServer = "media_server";
/**
 * User types
 */
export const UserTypeLocal = "local";
/**
 * LocalUserRegistrationRequest represents a request to create a local user
 */
export interface LocalUserRegistrationRequest {
  username: string;
  email: string;
  password: string;
}
/**
 * LocalUserLoginRequest represents a local user login request
 */
export interface LocalUserLoginRequest {
  username: string;
  password: string;
}
/**
 * ChangePasswordRequest represents a password change request for local users
 */
export interface ChangePasswordRequest {
  new_password: string;
}
export interface GetAllUsersResponse {
  total: number /* int64 */;
  users: UserWithPermissions[];
}

//////////
// source: websocket.go

export type Opcode = number /* uint8 */;
export const OpcodeDispatch: Opcode = 0; // Server sends event
export const OpcodeHello: Opcode = 1; // Server greets client
export const OpcodeHeartbeat: Opcode = 2; // Server/client keepalive
export const OpcodeReconnect: Opcode = 3; // Server requests reconnect
export const OpcodeAck: Opcode = 4; // Server acknowledges action
export const OpcodeError: Opcode = 5; // Server sends error
export const OpcodeDownloadProgress: Opcode = 10; // Server sends download progress
export const OpcodeDownloadRemoved: Opcode = 11; // Server notifies download removal
export const OpcodeDownloadProgressBatch: Opcode = 12; // Server sends batch download progress
export const OpcodeSystemStatus: Opcode = 13; // Server sends system status
export const OpcodeUserActivity: Opcode = 14; // Server sends user activity updates
export interface Message {
  op: Opcode; // Operation type
  t: number /* int64 */; // Millisecond timestamp
  d: any; // Any payload
  s?: number /* uint64 */; // Optional sequence number
}
/**
 * HelloPayload is sent when a client connects
 */
export interface HelloPayload {
  message: string;
  server_id?: string;
  features?: string[];
  metadata?: { [key: string]: string};
}
/**
 * ErrorPayload represents an error message
 */
export interface ErrorPayload {
  message: string;
  code?: string;
  request_id?: string;
}
/**
 * DownloadProgressPayload represents download progress
 */
export interface DownloadProgressPayload {
  id: string;
  title: string;
  torrent_title: string;
  source: string;
  tmdb_id?: number /* int64 */; // Optional TMDB ID
  tvdb_id?: number /* int64 */; // Optional TVDB ID
  hash: string;
  progress: number /* float64 */; // 0-100
  time_left: string;
  status: string;
  last_updated: string;
  download_speed?: number /* int64 */; // bytes per second
  download_size?: number /* int64 */; // total download size in bytes
}
/**
 * DownloadRemovedPayload represents a removed download
 */
export interface DownloadRemovedPayload {
  download_id: string;
  reason?: string;
}
/**
 * DownloadProgressBatchPayload represents multiple download updates
 */
export interface DownloadProgressBatchPayload {
  downloads: DownloadProgressPayload[];
  count: number /* int */;
  timestamp: number /* int64 */;
}
/**
 * SystemStatusPayload represents system status information
 */
export interface SystemStatusPayload {
  status: string; // "online", "maintenance", "error"
  uptime: number /* int64 */; // Server uptime in seconds
  connections: number /* int */; // Active WebSocket connections
  load?: { [key: string]: string}; // System load information
  memory?: { [key: string]: number /* int64 */}; // Memory usage
  disk?: { [key: string]: number /* int64 */}; // Disk usage
}
/**
 * UserActivityPayload represents user activity updates
 */
export interface UserActivityPayload {
  user_id: string;
  username: string;
  activity: string; // "login", "logout", "download_start", etc.
  timestamp: number /* int64 */;
  metadata?: { [key: string]: any};
}

//////////
// source: ratings.go

/**
 * Media ratings response
 */
export interface MediaRatingsResponse {
  rotten_tomatoes?: RottenTomatoesRating;
  // Future rating services can be added here
  // imdb?: IMDBRating;
  // metacritic?: MetacriticRating;
}

export interface RottenTomatoesRating {
  title: string;
  year: number /* int */;
  type: string;
  tomato_meter: number /* int */;
  url: string;
  critics_rating: string;
  critics_score: number /* int */;
  audience_rating: string;
  audience_score: number /* int */;
}
