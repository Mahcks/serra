// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: invitations.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const cancelInvitation = `-- name: CancelInvitation :one
UPDATE invitations 
SET status = 'cancelled', updated_at = CURRENT_TIMESTAMP
WHERE id = ? RETURNING id, email, username, token, invited_by, permissions, create_media_user, status, expires_at, accepted_at, created_at, updated_at
`

func (q *Queries) CancelInvitation(ctx context.Context, id int64) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, cancelInvitation, id)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Token,
		&i.InvitedBy,
		&i.Permissions,
		&i.CreateMediaUser,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (
    email, username, token, invited_by, permissions, create_media_user, expires_at
) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, email, username, token, invited_by, permissions, create_media_user, status, expires_at, accepted_at, created_at, updated_at
`

type CreateInvitationParams struct {
	Email           string         `json:"email"`
	Username        string         `json:"username"`
	Token           string         `json:"token"`
	InvitedBy       string         `json:"invited_by"`
	Permissions     sql.NullString `json:"permissions"`
	CreateMediaUser sql.NullBool   `json:"create_media_user"`
	ExpiresAt       time.Time      `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, createInvitation,
		arg.Email,
		arg.Username,
		arg.Token,
		arg.InvitedBy,
		arg.Permissions,
		arg.CreateMediaUser,
		arg.ExpiresAt,
	)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Token,
		&i.InvitedBy,
		&i.Permissions,
		&i.CreateMediaUser,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM invitations WHERE id = ?
`

func (q *Queries) DeleteInvitation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteInvitation, id)
	return err
}

const expireOldInvitations = `-- name: ExpireOldInvitations :exec
UPDATE invitations 
SET status = 'expired', updated_at = CURRENT_TIMESTAMP
WHERE status = 'pending' AND expires_at <= datetime('now')
`

func (q *Queries) ExpireOldInvitations(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, expireOldInvitations)
	return err
}

const getAllInvitations = `-- name: GetAllInvitations :many
SELECT 
    i.id, i.email, i.username, i.token, i.invited_by, i.permissions, i.create_media_user, i.status, i.expires_at, i.accepted_at, i.created_at, i.updated_at,
    u.username as inviter_username
FROM invitations i
LEFT JOIN users u ON i.invited_by = u.id
ORDER BY i.created_at DESC
`

type GetAllInvitationsRow struct {
	ID              int64          `json:"id"`
	Email           string         `json:"email"`
	Username        string         `json:"username"`
	Token           string         `json:"token"`
	InvitedBy       string         `json:"invited_by"`
	Permissions     sql.NullString `json:"permissions"`
	CreateMediaUser sql.NullBool   `json:"create_media_user"`
	Status          sql.NullString `json:"status"`
	ExpiresAt       time.Time      `json:"expires_at"`
	AcceptedAt      sql.NullTime   `json:"accepted_at"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	InviterUsername string         `json:"inviter_username"`
}

func (q *Queries) GetAllInvitations(ctx context.Context) ([]GetAllInvitationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllInvitationsRow
	for rows.Next() {
		var i GetAllInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Token,
			&i.InvitedBy,
			&i.Permissions,
			&i.CreateMediaUser,
			&i.Status,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InviterUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationByEmail = `-- name: GetInvitationByEmail :one
SELECT id, email, username, token, invited_by, permissions, create_media_user, status, expires_at, accepted_at, created_at, updated_at FROM invitations WHERE email = ? ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetInvitationByEmail(ctx context.Context, email string) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByEmail, email)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Token,
		&i.InvitedBy,
		&i.Permissions,
		&i.CreateMediaUser,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT id, email, username, token, invited_by, permissions, create_media_user, status, expires_at, accepted_at, created_at, updated_at FROM invitations WHERE id = ?
`

func (q *Queries) GetInvitationByID(ctx context.Context, id int64) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByID, id)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Token,
		&i.InvitedBy,
		&i.Permissions,
		&i.CreateMediaUser,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT id, email, username, token, invited_by, permissions, create_media_user, status, expires_at, accepted_at, created_at, updated_at FROM invitations WHERE token = ? AND status = 'pending' AND expires_at > datetime('now')
`

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByToken, token)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Token,
		&i.InvitedBy,
		&i.Permissions,
		&i.CreateMediaUser,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvitationStats = `-- name: GetInvitationStats :one
SELECT 
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
    COUNT(CASE WHEN status = 'accepted' THEN 1 END) as accepted_count,
    COUNT(CASE WHEN status = 'expired' THEN 1 END) as expired_count,
    COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_count,
    COUNT(*) as total_count
FROM invitations
`

type GetInvitationStatsRow struct {
	PendingCount   int64 `json:"pending_count"`
	AcceptedCount  int64 `json:"accepted_count"`
	ExpiredCount   int64 `json:"expired_count"`
	CancelledCount int64 `json:"cancelled_count"`
	TotalCount     int64 `json:"total_count"`
}

func (q *Queries) GetInvitationStats(ctx context.Context) (GetInvitationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getInvitationStats)
	var i GetInvitationStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.AcceptedCount,
		&i.ExpiredCount,
		&i.CancelledCount,
		&i.TotalCount,
	)
	return i, err
}

const getInvitationsByInviter = `-- name: GetInvitationsByInviter :many
SELECT id, email, username, token, invited_by, permissions, create_media_user, status, expires_at, accepted_at, created_at, updated_at FROM invitations WHERE invited_by = ? ORDER BY created_at DESC
`

func (q *Queries) GetInvitationsByInviter(ctx context.Context, invitedBy string) ([]Invitation, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationsByInviter, invitedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Token,
			&i.InvitedBy,
			&i.Permissions,
			&i.CreateMediaUser,
			&i.Status,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInvitations = `-- name: GetPendingInvitations :many
SELECT id, email, username, token, invited_by, permissions, create_media_user, status, expires_at, accepted_at, created_at, updated_at FROM invitations 
WHERE status = 'pending' AND expires_at > datetime('now')
ORDER BY created_at DESC
`

func (q *Queries) GetPendingInvitations(ctx context.Context) ([]Invitation, error) {
	rows, err := q.db.QueryContext(ctx, getPendingInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Token,
			&i.InvitedBy,
			&i.Permissions,
			&i.CreateMediaUser,
			&i.Status,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvitationStatus = `-- name: UpdateInvitationStatus :one
UPDATE invitations 
SET status = ?, updated_at = CURRENT_TIMESTAMP, accepted_at = CASE WHEN ? = 'accepted' THEN CURRENT_TIMESTAMP ELSE accepted_at END
WHERE token = ? RETURNING id, email, username, token, invited_by, permissions, create_media_user, status, expires_at, accepted_at, created_at, updated_at
`

type UpdateInvitationStatusParams struct {
	Status sql.NullString `json:"status"`
	Token  string         `json:"token"`
}

func (q *Queries) UpdateInvitationStatus(ctx context.Context, arg UpdateInvitationStatusParams) (Invitation, error) {
	row := q.db.QueryRowContext(ctx, updateInvitationStatus, arg.Status, arg.Token)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Token,
		&i.InvitedBy,
		&i.Permissions,
		&i.CreateMediaUser,
		&i.Status,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
