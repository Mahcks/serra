// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: notifications.sql

package repository

import (
	"context"
	"database/sql"
	"strings"
)

const bulkMarkAsRead = `-- name: BulkMarkAsRead :exec
UPDATE notifications 
SET read_at = CURRENT_TIMESTAMP 
WHERE id IN (/*SLICE:notification_ids*/?)
    AND user_id = ?
`

type BulkMarkAsReadParams struct {
	NotificationIds []string `json:"notification_ids"`
	UserID          string   `json:"user_id"`
}

func (q *Queries) BulkMarkAsRead(ctx context.Context, arg BulkMarkAsReadParams) error {
	query := bulkMarkAsRead
	var queryParams []interface{}
	if len(arg.NotificationIds) > 0 {
		for _, v := range arg.NotificationIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:notification_ids*/?", strings.Repeat(",?", len(arg.NotificationIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:notification_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UserID)
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const cleanupExpiredNotifications = `-- name: CleanupExpiredNotifications :exec
DELETE FROM notifications 
WHERE expires_at IS NOT NULL 
    AND expires_at <= CURRENT_TIMESTAMP
`

func (q *Queries) CleanupExpiredNotifications(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredNotifications)
	return err
}

const countUnreadNotifications = `-- name: CountUnreadNotifications :one
SELECT COUNT(*) 
FROM notifications 
WHERE user_id = ? 
    AND read_at IS NULL
    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
`

func (q *Queries) CountUnreadNotifications(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnreadNotifications, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNotification = `-- name: CreateNotification :exec
INSERT INTO notifications (
    id, user_id, title, message, type, priority, data, expires_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateNotificationParams struct {
	ID        string         `json:"id"`
	UserID    string         `json:"user_id"`
	Title     string         `json:"title"`
	Message   string         `json:"message"`
	Type      string         `json:"type"`
	Priority  string         `json:"priority"`
	Data      sql.NullString `json:"data"`
	ExpiresAt sql.NullTime   `json:"expires_at"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) error {
	_, err := q.db.ExecContext(ctx, createNotification,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Message,
		arg.Type,
		arg.Priority,
		arg.Data,
		arg.ExpiresAt,
	)
	return err
}

const dismissAllUserNotifications = `-- name: DismissAllUserNotifications :exec
DELETE FROM notifications 
WHERE user_id = ?
`

func (q *Queries) DismissAllUserNotifications(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, dismissAllUserNotifications, userID)
	return err
}

const dismissNotification = `-- name: DismissNotification :exec
DELETE FROM notifications 
WHERE id = ? AND user_id = ?
`

type DismissNotificationParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DismissNotification(ctx context.Context, arg DismissNotificationParams) error {
	_, err := q.db.ExecContext(ctx, dismissNotification, arg.ID, arg.UserID)
	return err
}

const getNotificationById = `-- name: GetNotificationById :one
SELECT 
    id, user_id, title, message, type, priority, data, read_at, created_at, expires_at
FROM notifications 
WHERE id = ?
`

func (q *Queries) GetNotificationById(ctx context.Context, id string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationById, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Message,
		&i.Type,
		&i.Priority,
		&i.Data,
		&i.ReadAt,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getNotificationsByType = `-- name: GetNotificationsByType :many
SELECT 
    id, user_id, title, message, type, priority, data, read_at, created_at, expires_at
FROM notifications 
WHERE user_id = ? 
    AND type = ?
    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetNotificationsByTypeParams struct {
	UserID string `json:"user_id"`
	Type   string `json:"type"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) GetNotificationsByType(ctx context.Context, arg GetNotificationsByTypeParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getNotificationsByType,
		arg.UserID,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Message,
			&i.Type,
			&i.Priority,
			&i.Data,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentNotifications = `-- name: GetRecentNotifications :many
SELECT 
    id, user_id, title, message, type, priority, data, read_at, created_at, expires_at
FROM notifications 
WHERE user_id = ? 
    AND created_at >= datetime('now', '-7 days')
    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
ORDER BY created_at DESC
LIMIT ?
`

type GetRecentNotificationsParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetRecentNotifications(ctx context.Context, arg GetRecentNotificationsParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getRecentNotifications, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Message,
			&i.Type,
			&i.Priority,
			&i.Data,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadUserNotifications = `-- name: GetUnreadUserNotifications :many
SELECT 
    id, user_id, title, message, type, priority, data, read_at, created_at, expires_at
FROM notifications 
WHERE user_id = ? 
    AND read_at IS NULL
    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
ORDER BY 
    CASE priority 
        WHEN 'urgent' THEN 1 
        WHEN 'high' THEN 2 
        WHEN 'normal' THEN 3 
        WHEN 'low' THEN 4 
    END ASC,
    created_at DESC
`

func (q *Queries) GetUnreadUserNotifications(ctx context.Context, userID string) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadUserNotifications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Message,
			&i.Type,
			&i.Priority,
			&i.Data,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT 
    id, user_id, title, message, type, priority, data, read_at, created_at, expires_at
FROM notifications 
WHERE user_id = ? 
    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
ORDER BY 
    CASE priority 
        WHEN 'urgent' THEN 1 
        WHEN 'high' THEN 2 
        WHEN 'normal' THEN 3 
        WHEN 'low' THEN 4 
    END ASC,
    created_at DESC
LIMIT ? OFFSET ?
`

type GetUserNotificationsParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getUserNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Message,
			&i.Type,
			&i.Priority,
			&i.Data,
			&i.ReadAt,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
UPDATE notifications 
SET read_at = CURRENT_TIMESTAMP 
WHERE id = ? AND user_id = ?
`

type MarkNotificationAsReadParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) error {
	_, err := q.db.ExecContext(ctx, markNotificationAsRead, arg.ID, arg.UserID)
	return err
}
