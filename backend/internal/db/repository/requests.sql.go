// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: requests.sql

package repository

import (
	"context"
	"database/sql"
)

const checkExistingRequest = `-- name: CheckExistingRequest :one
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE media_type = ? AND tmdb_id = ? AND user_id = ? AND seasons = ?
`

type CheckExistingRequestParams struct {
	MediaType string         `json:"media_type"`
	TmdbID    sql.NullInt64  `json:"tmdb_id"`
	UserID    string         `json:"user_id"`
	Seasons   sql.NullString `json:"seasons"`
}

func (q *Queries) CheckExistingRequest(ctx context.Context, arg CheckExistingRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, checkExistingRequest,
		arg.MediaType,
		arg.TmdbID,
		arg.UserID,
		arg.Seasons,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.Title,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FulfilledAt,
		&i.ApproverID,
		&i.OnBehalfOf,
		&i.PosterUrl,
		&i.Seasons,
		&i.SeasonStatuses,
	)
	return i, err
}

const checkExistingRequestAnySeasons = `-- name: CheckExistingRequestAnySeasons :many
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE media_type = ? AND tmdb_id = ? AND user_id = ?
`

type CheckExistingRequestAnySeasonsParams struct {
	MediaType string        `json:"media_type"`
	TmdbID    sql.NullInt64 `json:"tmdb_id"`
	UserID    string        `json:"user_id"`
}

func (q *Queries) CheckExistingRequestAnySeasons(ctx context.Context, arg CheckExistingRequestAnySeasonsParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, checkExistingRequestAnySeasons, arg.MediaType, arg.TmdbID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.Title,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FulfilledAt,
			&i.ApproverID,
			&i.OnBehalfOf,
			&i.PosterUrl,
			&i.Seasons,
			&i.SeasonStatuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkMultipleUserRequests = `-- name: CheckMultipleUserRequests :many
SELECT tmdb_id, COUNT(*) > 0 as requested
FROM requests 
WHERE tmdb_id IN (/*SLICE:tmdb_ids*/?) AND media_type = ? AND user_id = ?
GROUP BY tmdb_id
`

type CheckMultipleUserRequestsParams struct {
	TmdbID    sql.NullInt64 `json:"tmdb_id"`
	MediaType string        `json:"media_type"`
	UserID    string        `json:"user_id"`
}

type CheckMultipleUserRequestsRow struct {
	TmdbID    sql.NullInt64 `json:"tmdb_id"`
	Requested bool          `json:"requested"`
}

func (q *Queries) CheckMultipleUserRequests(ctx context.Context, arg CheckMultipleUserRequestsParams) ([]CheckMultipleUserRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, checkMultipleUserRequests, arg.TmdbID, arg.MediaType, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckMultipleUserRequestsRow
	for rows.Next() {
		var i CheckMultipleUserRequestsRow
		if err := rows.Scan(&i.TmdbID, &i.Requested); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkUserRequestExists = `-- name: CheckUserRequestExists :one
SELECT COUNT(*) > 0 as requested
FROM requests 
WHERE tmdb_id = ? AND media_type = ? AND user_id = ?
`

type CheckUserRequestExistsParams struct {
	TmdbID    sql.NullInt64 `json:"tmdb_id"`
	MediaType string        `json:"media_type"`
	UserID    string        `json:"user_id"`
}

func (q *Queries) CheckUserRequestExists(ctx context.Context, arg CheckUserRequestExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserRequestExists, arg.TmdbID, arg.MediaType, arg.UserID)
	var requested bool
	err := row.Scan(&requested)
	return requested, err
}

const createRequest = `-- name: CreateRequest :one
INSERT INTO requests (user_id, media_type, tmdb_id, title, status, notes, poster_url, on_behalf_of, seasons, season_statuses)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
`

type CreateRequestParams struct {
	UserID         string         `json:"user_id"`
	MediaType      string         `json:"media_type"`
	TmdbID         sql.NullInt64  `json:"tmdb_id"`
	Title          sql.NullString `json:"title"`
	Status         string         `json:"status"`
	Notes          sql.NullString `json:"notes"`
	PosterUrl      sql.NullString `json:"poster_url"`
	OnBehalfOf     sql.NullString `json:"on_behalf_of"`
	Seasons        sql.NullString `json:"seasons"`
	SeasonStatuses sql.NullString `json:"season_statuses"`
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, createRequest,
		arg.UserID,
		arg.MediaType,
		arg.TmdbID,
		arg.Title,
		arg.Status,
		arg.Notes,
		arg.PosterUrl,
		arg.OnBehalfOf,
		arg.Seasons,
		arg.SeasonStatuses,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.Title,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FulfilledAt,
		&i.ApproverID,
		&i.OnBehalfOf,
		&i.PosterUrl,
		&i.Seasons,
		&i.SeasonStatuses,
	)
	return i, err
}

const deleteRequest = `-- name: DeleteRequest :exec
DELETE FROM requests WHERE id = ?
`

func (q *Queries) DeleteRequest(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRequest, id)
	return err
}

const fulfillRequest = `-- name: FulfillRequest :one
UPDATE requests
SET status = 'fulfilled', fulfilled_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
`

func (q *Queries) FulfillRequest(ctx context.Context, id int64) (Request, error) {
	row := q.db.QueryRowContext(ctx, fulfillRequest, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.Title,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FulfilledAt,
		&i.ApproverID,
		&i.OnBehalfOf,
		&i.PosterUrl,
		&i.Seasons,
		&i.SeasonStatuses,
	)
	return i, err
}

const getAllRequests = `-- name: GetAllRequests :many
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
ORDER BY created_at DESC
`

func (q *Queries) GetAllRequests(ctx context.Context) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getAllRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.Title,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FulfilledAt,
			&i.ApproverID,
			&i.OnBehalfOf,
			&i.PosterUrl,
			&i.Seasons,
			&i.SeasonStatuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRequests = `-- name: GetPendingRequests :many
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) GetPendingRequests(ctx context.Context) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getPendingRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.Title,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FulfilledAt,
			&i.ApproverID,
			&i.OnBehalfOf,
			&i.PosterUrl,
			&i.Seasons,
			&i.SeasonStatuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentRequests = `-- name: GetRecentRequests :many
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE created_at >= datetime('now', '-7 days')
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentRequests(ctx context.Context, limit int64) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getRecentRequests, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.Title,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FulfilledAt,
			&i.ApproverID,
			&i.OnBehalfOf,
			&i.PosterUrl,
			&i.Seasons,
			&i.SeasonStatuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestByID = `-- name: GetRequestByID :one
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE id = ?
`

func (q *Queries) GetRequestByID(ctx context.Context, id int64) (Request, error) {
	row := q.db.QueryRowContext(ctx, getRequestByID, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.Title,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FulfilledAt,
		&i.ApproverID,
		&i.OnBehalfOf,
		&i.PosterUrl,
		&i.Seasons,
		&i.SeasonStatuses,
	)
	return i, err
}

const getRequestStatistics = `-- name: GetRequestStatistics :one
SELECT 
    COUNT(*) as total_requests,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_requests,
    COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_requests,
    COUNT(CASE WHEN status = 'fulfilled' THEN 1 END) as fulfilled_requests,
    COUNT(CASE WHEN status = 'denied' THEN 1 END) as denied_requests
FROM requests
`

type GetRequestStatisticsRow struct {
	TotalRequests     int64 `json:"total_requests"`
	PendingRequests   int64 `json:"pending_requests"`
	ApprovedRequests  int64 `json:"approved_requests"`
	FulfilledRequests int64 `json:"fulfilled_requests"`
	DeniedRequests    int64 `json:"denied_requests"`
}

func (q *Queries) GetRequestStatistics(ctx context.Context) (GetRequestStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getRequestStatistics)
	var i GetRequestStatisticsRow
	err := row.Scan(
		&i.TotalRequests,
		&i.PendingRequests,
		&i.ApprovedRequests,
		&i.FulfilledRequests,
		&i.DeniedRequests,
	)
	return i, err
}

const getRequestsByStatus = `-- name: GetRequestsByStatus :many
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) GetRequestsByStatus(ctx context.Context, status string) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getRequestsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.Title,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FulfilledAt,
			&i.ApproverID,
			&i.OnBehalfOf,
			&i.PosterUrl,
			&i.Seasons,
			&i.SeasonStatuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestsByTMDBIDAndMediaType = `-- name: GetRequestsByTMDBIDAndMediaType :many
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE tmdb_id = ? AND media_type = ?
`

type GetRequestsByTMDBIDAndMediaTypeParams struct {
	TmdbID    sql.NullInt64 `json:"tmdb_id"`
	MediaType string        `json:"media_type"`
}

func (q *Queries) GetRequestsByTMDBIDAndMediaType(ctx context.Context, arg GetRequestsByTMDBIDAndMediaTypeParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getRequestsByTMDBIDAndMediaType, arg.TmdbID, arg.MediaType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.Title,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FulfilledAt,
			&i.ApproverID,
			&i.OnBehalfOf,
			&i.PosterUrl,
			&i.Seasons,
			&i.SeasonStatuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestsByUser = `-- name: GetRequestsByUser :many
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetRequestsByUser(ctx context.Context, userID string) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getRequestsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.Title,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FulfilledAt,
			&i.ApproverID,
			&i.OnBehalfOf,
			&i.PosterUrl,
			&i.Seasons,
			&i.SeasonStatuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestsForUser = `-- name: GetRequestsForUser :many
SELECT id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
FROM requests
WHERE user_id = ? OR on_behalf_of = ?
ORDER BY created_at DESC
`

type GetRequestsForUserParams struct {
	UserID     string         `json:"user_id"`
	OnBehalfOf sql.NullString `json:"on_behalf_of"`
}

func (q *Queries) GetRequestsForUser(ctx context.Context, arg GetRequestsForUserParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getRequestsForUser, arg.UserID, arg.OnBehalfOf)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.Title,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FulfilledAt,
			&i.ApproverID,
			&i.OnBehalfOf,
			&i.PosterUrl,
			&i.Seasons,
			&i.SeasonStatuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequestStatus = `-- name: UpdateRequestStatus :one
UPDATE requests
SET status = ?, approver_id = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
`

type UpdateRequestStatusParams struct {
	Status     string         `json:"status"`
	ApproverID sql.NullString `json:"approver_id"`
	ID         int64          `json:"id"`
}

func (q *Queries) UpdateRequestStatus(ctx context.Context, arg UpdateRequestStatusParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, updateRequestStatus, arg.Status, arg.ApproverID, arg.ID)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.Title,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FulfilledAt,
		&i.ApproverID,
		&i.OnBehalfOf,
		&i.PosterUrl,
		&i.Seasons,
		&i.SeasonStatuses,
	)
	return i, err
}

const updateRequestStatusOnly = `-- name: UpdateRequestStatusOnly :one
UPDATE requests
SET status = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, media_type, tmdb_id, title, status, notes, created_at, updated_at, fulfilled_at, approver_id, on_behalf_of, poster_url, seasons, season_statuses
`

type UpdateRequestStatusOnlyParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateRequestStatusOnly(ctx context.Context, arg UpdateRequestStatusOnlyParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, updateRequestStatusOnly, arg.Status, arg.ID)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.Title,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FulfilledAt,
		&i.ApproverID,
		&i.OnBehalfOf,
		&i.PosterUrl,
		&i.Seasons,
		&i.SeasonStatuses,
	)
	return i, err
}
