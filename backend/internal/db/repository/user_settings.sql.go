// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: user_settings.sql

package repository

import (
	"context"
	"database/sql"
)

const deleteAllUserSettings = `-- name: DeleteAllUserSettings :exec
DELETE FROM user_settings 
WHERE user_id = ?
`

func (q *Queries) DeleteAllUserSettings(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllUserSettings, userID)
	return err
}

const deleteUserSetting = `-- name: DeleteUserSetting :exec
DELETE FROM user_settings 
WHERE user_id = ? AND key = ?
`

type DeleteUserSettingParams struct {
	UserID string `json:"user_id"`
	Key    string `json:"key"`
}

func (q *Queries) DeleteUserSetting(ctx context.Context, arg DeleteUserSettingParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserSetting, arg.UserID, arg.Key)
	return err
}

const getAllUserSettings = `-- name: GetAllUserSettings :many
SELECT key, value, updated_at
FROM user_settings 
WHERE user_id = ?
ORDER BY key ASC
`

type GetAllUserSettingsRow struct {
	Key       string       `json:"key"`
	Value     string       `json:"value"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

func (q *Queries) GetAllUserSettings(ctx context.Context, userID string) ([]GetAllUserSettingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserSettings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserSettingsRow
	for rows.Next() {
		var i GetAllUserSettingsRow
		if err := rows.Scan(&i.Key, &i.Value, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSetting = `-- name: GetUserSetting :one
SELECT value 
FROM user_settings 
WHERE user_id = ? AND key = ?
`

type GetUserSettingParams struct {
	UserID string `json:"user_id"`
	Key    string `json:"key"`
}

func (q *Queries) GetUserSetting(ctx context.Context, arg GetUserSettingParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserSetting, arg.UserID, arg.Key)
	var value string
	err := row.Scan(&value)
	return value, err
}

const setUserSetting = `-- name: SetUserSetting :exec
INSERT INTO user_settings (user_id, key, value, updated_at)
VALUES (?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT (user_id, key) 
DO UPDATE SET 
    value = excluded.value,
    updated_at = CURRENT_TIMESTAMP
`

type SetUserSettingParams struct {
	UserID string `json:"user_id"`
	Key    string `json:"key"`
	Value  string `json:"value"`
}

func (q *Queries) SetUserSetting(ctx context.Context, arg SetUserSettingParams) error {
	_, err := q.db.ExecContext(ctx, setUserSetting, arg.UserID, arg.Key, arg.Value)
	return err
}
