// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: library.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const checkMediaInLibrary = `-- name: CheckMediaInLibrary :one
SELECT COUNT(*) > 0 as in_library 
FROM library_items 
WHERE tmdb_id = ?
`

func (q *Queries) CheckMediaInLibrary(ctx context.Context, tmdbID sql.NullString) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkMediaInLibrary, tmdbID)
	var in_library bool
	err := row.Scan(&in_library)
	return in_library, err
}

const checkMultipleMediaInLibrary = `-- name: CheckMultipleMediaInLibrary :many
SELECT tmdb_id, COUNT(*) > 0 as in_library
FROM library_items 
WHERE tmdb_id IN (/*SLICE:tmdb_ids*/?)
GROUP BY tmdb_id
`

type CheckMultipleMediaInLibraryRow struct {
	TmdbID    sql.NullString `json:"tmdb_id"`
	InLibrary bool           `json:"in_library"`
}

func (q *Queries) CheckMultipleMediaInLibrary(ctx context.Context, tmdbID sql.NullString) ([]CheckMultipleMediaInLibraryRow, error) {
	rows, err := q.db.QueryContext(ctx, checkMultipleMediaInLibrary, tmdbID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckMultipleMediaInLibraryRow
	for rows.Next() {
		var i CheckMultipleMediaInLibraryRow
		if err := rows.Scan(&i.TmdbID, &i.InLibrary); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createEmbyMediaItem = `-- name: CreateEmbyMediaItem :one
INSERT INTO library_items (id, name, type, year, tmdb_id, imdb_id, tvdb_id, path, runtime_ticks, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, type, year, tmdb_id, imdb_id, tvdb_id, path, runtime_ticks, updated_at
`

type CreateEmbyMediaItemParams struct {
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Type         string         `json:"type"`
	Year         sql.NullInt64  `json:"year"`
	TmdbID       sql.NullString `json:"tmdb_id"`
	ImdbID       sql.NullString `json:"imdb_id"`
	TvdbID       sql.NullString `json:"tvdb_id"`
	Path         sql.NullString `json:"path"`
	RuntimeTicks sql.NullInt64  `json:"runtime_ticks"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

type CreateEmbyMediaItemRow struct {
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Type         string         `json:"type"`
	Year         sql.NullInt64  `json:"year"`
	TmdbID       sql.NullString `json:"tmdb_id"`
	ImdbID       sql.NullString `json:"imdb_id"`
	TvdbID       sql.NullString `json:"tvdb_id"`
	Path         sql.NullString `json:"path"`
	RuntimeTicks sql.NullInt64  `json:"runtime_ticks"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

// Compatibility query for legacy CreateEmbyMediaItem usage
func (q *Queries) CreateEmbyMediaItem(ctx context.Context, arg CreateEmbyMediaItemParams) (CreateEmbyMediaItemRow, error) {
	row := q.db.QueryRowContext(ctx, createEmbyMediaItem,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.Path,
		arg.RuntimeTicks,
		arg.UpdatedAt,
	)
	var i CreateEmbyMediaItemRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.Path,
		&i.RuntimeTicks,
		&i.UpdatedAt,
	)
	return i, err
}

const createLibraryItem = `-- name: CreateLibraryItem :one
INSERT INTO library_items (
    id, name, type, year, tmdb_id, imdb_id, tvdb_id, path, runtime_ticks, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, original_title, type, parent_id, series_id, season_number, episode_number, year, premiere_date, end_date, 
          community_rating, critic_rating, official_rating, overview, tagline, genres, studios, people,
          tmdb_id, imdb_id, tvdb_id, musicbrainz_id, path, container, size_bytes, bitrate, width, height, 
          aspect_ratio, video_codec, audio_codec, subtitle_tracks, audio_tracks, runtime_ticks, runtime_minutes,
          is_folder, is_resumable, play_count, date_created, date_modified, last_played_date, user_data,
          chapter_images_extracted, primary_image_tag, backdrop_image_tags, logo_image_tag, art_image_tag, 
          thumb_image_tag, is_hd, is_4k, is_3d, locked, provider_ids, external_urls, tags, sort_name, 
          forced_sort_name, created_at, updated_at
`

type CreateLibraryItemParams struct {
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Type         string         `json:"type"`
	Year         sql.NullInt64  `json:"year"`
	TmdbID       sql.NullString `json:"tmdb_id"`
	ImdbID       sql.NullString `json:"imdb_id"`
	TvdbID       sql.NullString `json:"tvdb_id"`
	Path         sql.NullString `json:"path"`
	RuntimeTicks sql.NullInt64  `json:"runtime_ticks"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

func (q *Queries) CreateLibraryItem(ctx context.Context, arg CreateLibraryItemParams) (LibraryItem, error) {
	row := q.db.QueryRowContext(ctx, createLibraryItem,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.Path,
		arg.RuntimeTicks,
		arg.UpdatedAt,
	)
	var i LibraryItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalTitle,
		&i.Type,
		&i.ParentID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Year,
		&i.PremiereDate,
		&i.EndDate,
		&i.CommunityRating,
		&i.CriticRating,
		&i.OfficialRating,
		&i.Overview,
		&i.Tagline,
		&i.Genres,
		&i.Studios,
		&i.People,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.MusicbrainzID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.Bitrate,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.SubtitleTracks,
		&i.AudioTracks,
		&i.RuntimeTicks,
		&i.RuntimeMinutes,
		&i.IsFolder,
		&i.IsResumable,
		&i.PlayCount,
		&i.DateCreated,
		&i.DateModified,
		&i.LastPlayedDate,
		&i.UserData,
		&i.ChapterImagesExtracted,
		&i.PrimaryImageTag,
		&i.BackdropImageTags,
		&i.LogoImageTag,
		&i.ArtImageTag,
		&i.ThumbImageTag,
		&i.IsHd,
		&i.Is4k,
		&i.Is3d,
		&i.Locked,
		&i.ProviderIds,
		&i.ExternalUrls,
		&i.Tags,
		&i.SortName,
		&i.ForcedSortName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLibraryItemFull = `-- name: CreateLibraryItemFull :one
INSERT INTO library_items (
    id, name, original_title, type, parent_id, series_id, season_number, episode_number, year, premiere_date, end_date, 
    community_rating, critic_rating, official_rating, overview, tagline, genres, studios, people,
    tmdb_id, imdb_id, tvdb_id, musicbrainz_id, path, container, size_bytes, bitrate, width, height, 
    aspect_ratio, video_codec, audio_codec, subtitle_tracks, audio_tracks, runtime_ticks, runtime_minutes,
    is_folder, is_resumable, play_count, date_created, date_modified, last_played_date, user_data,
    chapter_images_extracted, primary_image_tag, backdrop_image_tags, logo_image_tag, art_image_tag, 
    thumb_image_tag, is_hd, is_4k, is_3d, locked, provider_ids, external_urls, tags, sort_name, 
    forced_sort_name, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, original_title, type, parent_id, series_id, season_number, episode_number, year, premiere_date, end_date, 
          community_rating, critic_rating, official_rating, overview, tagline, genres, studios, people,
          tmdb_id, imdb_id, tvdb_id, musicbrainz_id, path, container, size_bytes, bitrate, width, height, 
          aspect_ratio, video_codec, audio_codec, subtitle_tracks, audio_tracks, runtime_ticks, runtime_minutes,
          is_folder, is_resumable, play_count, date_created, date_modified, last_played_date, user_data,
          chapter_images_extracted, primary_image_tag, backdrop_image_tags, logo_image_tag, art_image_tag, 
          thumb_image_tag, is_hd, is_4k, is_3d, locked, provider_ids, external_urls, tags, sort_name, 
          forced_sort_name, created_at, updated_at
`

type CreateLibraryItemFullParams struct {
	ID                     string          `json:"id"`
	Name                   string          `json:"name"`
	OriginalTitle          sql.NullString  `json:"original_title"`
	Type                   string          `json:"type"`
	ParentID               sql.NullString  `json:"parent_id"`
	SeriesID               sql.NullString  `json:"series_id"`
	SeasonNumber           sql.NullInt64   `json:"season_number"`
	EpisodeNumber          sql.NullInt64   `json:"episode_number"`
	Year                   sql.NullInt64   `json:"year"`
	PremiereDate           sql.NullString  `json:"premiere_date"`
	EndDate                sql.NullString  `json:"end_date"`
	CommunityRating        sql.NullFloat64 `json:"community_rating"`
	CriticRating           sql.NullFloat64 `json:"critic_rating"`
	OfficialRating         sql.NullString  `json:"official_rating"`
	Overview               sql.NullString  `json:"overview"`
	Tagline                sql.NullString  `json:"tagline"`
	Genres                 sql.NullString  `json:"genres"`
	Studios                sql.NullString  `json:"studios"`
	People                 sql.NullString  `json:"people"`
	TmdbID                 sql.NullString  `json:"tmdb_id"`
	ImdbID                 sql.NullString  `json:"imdb_id"`
	TvdbID                 sql.NullString  `json:"tvdb_id"`
	MusicbrainzID          sql.NullString  `json:"musicbrainz_id"`
	Path                   sql.NullString  `json:"path"`
	Container              sql.NullString  `json:"container"`
	SizeBytes              sql.NullInt64   `json:"size_bytes"`
	Bitrate                sql.NullInt64   `json:"bitrate"`
	Width                  sql.NullInt64   `json:"width"`
	Height                 sql.NullInt64   `json:"height"`
	AspectRatio            sql.NullString  `json:"aspect_ratio"`
	VideoCodec             sql.NullString  `json:"video_codec"`
	AudioCodec             sql.NullString  `json:"audio_codec"`
	SubtitleTracks         sql.NullString  `json:"subtitle_tracks"`
	AudioTracks            sql.NullString  `json:"audio_tracks"`
	RuntimeTicks           sql.NullInt64   `json:"runtime_ticks"`
	RuntimeMinutes         sql.NullInt64   `json:"runtime_minutes"`
	IsFolder               sql.NullBool    `json:"is_folder"`
	IsResumable            sql.NullBool    `json:"is_resumable"`
	PlayCount              sql.NullInt64   `json:"play_count"`
	DateCreated            sql.NullString  `json:"date_created"`
	DateModified           sql.NullString  `json:"date_modified"`
	LastPlayedDate         sql.NullString  `json:"last_played_date"`
	UserData               sql.NullString  `json:"user_data"`
	ChapterImagesExtracted sql.NullBool    `json:"chapter_images_extracted"`
	PrimaryImageTag        sql.NullString  `json:"primary_image_tag"`
	BackdropImageTags      sql.NullString  `json:"backdrop_image_tags"`
	LogoImageTag           sql.NullString  `json:"logo_image_tag"`
	ArtImageTag            sql.NullString  `json:"art_image_tag"`
	ThumbImageTag          sql.NullString  `json:"thumb_image_tag"`
	IsHd                   sql.NullBool    `json:"is_hd"`
	Is4k                   sql.NullBool    `json:"is_4k"`
	Is3d                   sql.NullBool    `json:"is_3d"`
	Locked                 sql.NullBool    `json:"locked"`
	ProviderIds            sql.NullString  `json:"provider_ids"`
	ExternalUrls           sql.NullString  `json:"external_urls"`
	Tags                   sql.NullString  `json:"tags"`
	SortName               sql.NullString  `json:"sort_name"`
	ForcedSortName         sql.NullString  `json:"forced_sort_name"`
	CreatedAt              time.Time       `json:"created_at"`
	UpdatedAt              time.Time       `json:"updated_at"`
}

func (q *Queries) CreateLibraryItemFull(ctx context.Context, arg CreateLibraryItemFullParams) (LibraryItem, error) {
	row := q.db.QueryRowContext(ctx, createLibraryItemFull,
		arg.ID,
		arg.Name,
		arg.OriginalTitle,
		arg.Type,
		arg.ParentID,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Year,
		arg.PremiereDate,
		arg.EndDate,
		arg.CommunityRating,
		arg.CriticRating,
		arg.OfficialRating,
		arg.Overview,
		arg.Tagline,
		arg.Genres,
		arg.Studios,
		arg.People,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.MusicbrainzID,
		arg.Path,
		arg.Container,
		arg.SizeBytes,
		arg.Bitrate,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.SubtitleTracks,
		arg.AudioTracks,
		arg.RuntimeTicks,
		arg.RuntimeMinutes,
		arg.IsFolder,
		arg.IsResumable,
		arg.PlayCount,
		arg.DateCreated,
		arg.DateModified,
		arg.LastPlayedDate,
		arg.UserData,
		arg.ChapterImagesExtracted,
		arg.PrimaryImageTag,
		arg.BackdropImageTags,
		arg.LogoImageTag,
		arg.ArtImageTag,
		arg.ThumbImageTag,
		arg.IsHd,
		arg.Is4k,
		arg.Is3d,
		arg.Locked,
		arg.ProviderIds,
		arg.ExternalUrls,
		arg.Tags,
		arg.SortName,
		arg.ForcedSortName,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i LibraryItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalTitle,
		&i.Type,
		&i.ParentID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Year,
		&i.PremiereDate,
		&i.EndDate,
		&i.CommunityRating,
		&i.CriticRating,
		&i.OfficialRating,
		&i.Overview,
		&i.Tagline,
		&i.Genres,
		&i.Studios,
		&i.People,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.MusicbrainzID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.Bitrate,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.SubtitleTracks,
		&i.AudioTracks,
		&i.RuntimeTicks,
		&i.RuntimeMinutes,
		&i.IsFolder,
		&i.IsResumable,
		&i.PlayCount,
		&i.DateCreated,
		&i.DateModified,
		&i.LastPlayedDate,
		&i.UserData,
		&i.ChapterImagesExtracted,
		&i.PrimaryImageTag,
		&i.BackdropImageTags,
		&i.LogoImageTag,
		&i.ArtImageTag,
		&i.ThumbImageTag,
		&i.IsHd,
		&i.Is4k,
		&i.Is3d,
		&i.Locked,
		&i.ProviderIds,
		&i.ExternalUrls,
		&i.Tags,
		&i.SortName,
		&i.ForcedSortName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLibraryItemByTMDBID = `-- name: GetLibraryItemByTMDBID :one
SELECT id, name, original_title, type, parent_id, series_id, season_number, episode_number, year, premiere_date, end_date, 
       community_rating, critic_rating, official_rating, overview, tagline, genres, studios, people,
       tmdb_id, imdb_id, tvdb_id, musicbrainz_id, path, container, size_bytes, bitrate, width, height, 
       aspect_ratio, video_codec, audio_codec, subtitle_tracks, audio_tracks, runtime_ticks, runtime_minutes,
       is_folder, is_resumable, play_count, date_created, date_modified, last_played_date, user_data,
       chapter_images_extracted, primary_image_tag, backdrop_image_tags, logo_image_tag, art_image_tag, 
       thumb_image_tag, is_hd, is_4k, is_3d, locked, provider_ids, external_urls, tags, sort_name, 
       forced_sort_name, created_at, updated_at
FROM library_items
WHERE tmdb_id = ?
LIMIT 1
`

func (q *Queries) GetLibraryItemByTMDBID(ctx context.Context, tmdbID sql.NullString) (LibraryItem, error) {
	row := q.db.QueryRowContext(ctx, getLibraryItemByTMDBID, tmdbID)
	var i LibraryItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalTitle,
		&i.Type,
		&i.ParentID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Year,
		&i.PremiereDate,
		&i.EndDate,
		&i.CommunityRating,
		&i.CriticRating,
		&i.OfficialRating,
		&i.Overview,
		&i.Tagline,
		&i.Genres,
		&i.Studios,
		&i.People,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.MusicbrainzID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.Bitrate,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.SubtitleTracks,
		&i.AudioTracks,
		&i.RuntimeTicks,
		&i.RuntimeMinutes,
		&i.IsFolder,
		&i.IsResumable,
		&i.PlayCount,
		&i.DateCreated,
		&i.DateModified,
		&i.LastPlayedDate,
		&i.UserData,
		&i.ChapterImagesExtracted,
		&i.PrimaryImageTag,
		&i.BackdropImageTags,
		&i.LogoImageTag,
		&i.ArtImageTag,
		&i.ThumbImageTag,
		&i.IsHd,
		&i.Is4k,
		&i.Is3d,
		&i.Locked,
		&i.ProviderIds,
		&i.ExternalUrls,
		&i.Tags,
		&i.SortName,
		&i.ForcedSortName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchLibraryByTitle = `-- name: SearchLibraryByTitle :many
SELECT id, name, original_title, type, parent_id, series_id, season_number, episode_number, year, premiere_date, end_date, 
       community_rating, critic_rating, official_rating, overview, tagline, genres, studios, people,
       tmdb_id, imdb_id, tvdb_id, musicbrainz_id, path, container, size_bytes, bitrate, width, height, 
       aspect_ratio, video_codec, audio_codec, subtitle_tracks, audio_tracks, runtime_ticks, runtime_minutes,
       is_folder, is_resumable, play_count, date_created, date_modified, last_played_date, user_data,
       chapter_images_extracted, primary_image_tag, backdrop_image_tags, logo_image_tag, art_image_tag, 
       thumb_image_tag, is_hd, is_4k, is_3d, locked, provider_ids, external_urls, tags, sort_name, 
       forced_sort_name, created_at, updated_at
FROM library_items
WHERE name LIKE '%' || ? || '%'
ORDER BY name
LIMIT ?
`

type SearchLibraryByTitleParams struct {
	Name  string `json:"name"`
	Limit int64  `json:"limit"`
}

func (q *Queries) SearchLibraryByTitle(ctx context.Context, arg SearchLibraryByTitleParams) ([]LibraryItem, error) {
	rows, err := q.db.QueryContext(ctx, searchLibraryByTitle, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LibraryItem
	for rows.Next() {
		var i LibraryItem
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalTitle,
			&i.Type,
			&i.ParentID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Year,
			&i.PremiereDate,
			&i.EndDate,
			&i.CommunityRating,
			&i.CriticRating,
			&i.OfficialRating,
			&i.Overview,
			&i.Tagline,
			&i.Genres,
			&i.Studios,
			&i.People,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.MusicbrainzID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.Bitrate,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.SubtitleTracks,
			&i.AudioTracks,
			&i.RuntimeTicks,
			&i.RuntimeMinutes,
			&i.IsFolder,
			&i.IsResumable,
			&i.PlayCount,
			&i.DateCreated,
			&i.DateModified,
			&i.LastPlayedDate,
			&i.UserData,
			&i.ChapterImagesExtracted,
			&i.PrimaryImageTag,
			&i.BackdropImageTags,
			&i.LogoImageTag,
			&i.ArtImageTag,
			&i.ThumbImageTag,
			&i.IsHd,
			&i.Is4k,
			&i.Is3d,
			&i.Locked,
			&i.ProviderIds,
			&i.ExternalUrls,
			&i.Tags,
			&i.SortName,
			&i.ForcedSortName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
