// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: analytics.sql

package repository

import (
	"context"
	"database/sql"
)

const clearDriveAlerts = `-- name: ClearDriveAlerts :exec
UPDATE drive_alerts 
SET is_active = FALSE
WHERE drive_id = ? AND is_active = TRUE
`

func (q *Queries) ClearDriveAlerts(ctx context.Context, driveID string) error {
	_, err := q.db.ExecContext(ctx, clearDriveAlerts, driveID)
	return err
}

const createDriveAlert = `-- name: CreateDriveAlert :one
INSERT INTO drive_alerts (drive_id, alert_type, threshold_value, current_value, alert_message)
VALUES (?, ?, ?, ?, ?)
RETURNING id, drive_id, alert_type, threshold_value, current_value, alert_message, is_active, last_triggered, acknowledgement_count, created_at
`

type CreateDriveAlertParams struct {
	DriveID        string  `json:"drive_id"`
	AlertType      string  `json:"alert_type"`
	ThresholdValue float64 `json:"threshold_value"`
	CurrentValue   float64 `json:"current_value"`
	AlertMessage   string  `json:"alert_message"`
}

func (q *Queries) CreateDriveAlert(ctx context.Context, arg CreateDriveAlertParams) (DriveAlert, error) {
	row := q.db.QueryRowContext(ctx, createDriveAlert,
		arg.DriveID,
		arg.AlertType,
		arg.ThresholdValue,
		arg.CurrentValue,
		arg.AlertMessage,
	)
	var i DriveAlert
	err := row.Scan(
		&i.ID,
		&i.DriveID,
		&i.AlertType,
		&i.ThresholdValue,
		&i.CurrentValue,
		&i.AlertMessage,
		&i.IsActive,
		&i.LastTriggered,
		&i.AcknowledgementCount,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateDriveAlert = `-- name: DeactivateDriveAlert :exec
UPDATE drive_alerts 
SET is_active = FALSE, acknowledgement_count = acknowledgement_count + 1
WHERE id = ?
`

func (q *Queries) DeactivateDriveAlert(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deactivateDriveAlert, id)
	return err
}

const getActiveDriveAlerts = `-- name: GetActiveDriveAlerts :many
SELECT da.id, da.drive_id, da.alert_type, da.threshold_value, da.current_value, da.alert_message, da.is_active, da.last_triggered, da.acknowledgement_count, da.created_at, md.name as drive_name, md.mount_path 
FROM drive_alerts da
JOIN mounted_drives md ON da.drive_id = md.id
WHERE da.is_active = TRUE
ORDER BY da.last_triggered DESC
`

type GetActiveDriveAlertsRow struct {
	ID                   int64         `json:"id"`
	DriveID              string        `json:"drive_id"`
	AlertType            string        `json:"alert_type"`
	ThresholdValue       float64       `json:"threshold_value"`
	CurrentValue         float64       `json:"current_value"`
	AlertMessage         string        `json:"alert_message"`
	IsActive             sql.NullBool  `json:"is_active"`
	LastTriggered        sql.NullTime  `json:"last_triggered"`
	AcknowledgementCount sql.NullInt64 `json:"acknowledgement_count"`
	CreatedAt            sql.NullTime  `json:"created_at"`
	DriveName            string        `json:"drive_name"`
	MountPath            string        `json:"mount_path"`
}

func (q *Queries) GetActiveDriveAlerts(ctx context.Context) ([]GetActiveDriveAlertsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveDriveAlerts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveDriveAlertsRow
	for rows.Next() {
		var i GetActiveDriveAlertsRow
		if err := rows.Scan(
			&i.ID,
			&i.DriveID,
			&i.AlertType,
			&i.ThresholdValue,
			&i.CurrentValue,
			&i.AlertMessage,
			&i.IsActive,
			&i.LastTriggered,
			&i.AcknowledgementCount,
			&i.CreatedAt,
			&i.DriveName,
			&i.MountPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAverageProcessingTime = `-- name: GetAverageProcessingTime :one
SELECT 
    AVG(
        CASE 
            WHEN rm_end.timestamp IS NOT NULL THEN 
                (julianday(rm_end.timestamp) - julianday(rm_start.timestamp)) * 24 * 60 * 60
            ELSE NULL 
        END
    ) as avg_processing_seconds
FROM request_metrics rm_start
LEFT JOIN request_metrics rm_end ON rm_start.request_id = rm_end.request_id 
    AND rm_end.new_status IN ('fulfilled', 'failed')
WHERE rm_start.status_change = 'created'
AND rm_start.timestamp >= datetime('now', '-' || ? || ' days')
`

func (q *Queries) GetAverageProcessingTime(ctx context.Context) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getAverageProcessingTime)
	var avg_processing_seconds sql.NullFloat64
	err := row.Scan(&avg_processing_seconds)
	return avg_processing_seconds, err
}

const getDriveGrowthPrediction = `-- name: GetDriveGrowthPrediction :many
SELECT 
    drive_id,
    AVG(growth_rate_gb_per_day) as avg_growth_rate_gb_per_day,
    AVG(usage_percentage) as current_avg_usage,
    MIN(projected_full_date) as earliest_full_date
FROM drive_usage_history
WHERE recorded_at >= datetime('now', '-' || ?1 || ' days')
GROUP BY drive_id
HAVING COUNT(*) >= 2
ORDER BY current_avg_usage DESC
`

type GetDriveGrowthPredictionRow struct {
	DriveID               string          `json:"drive_id"`
	AvgGrowthRateGbPerDay sql.NullFloat64 `json:"avg_growth_rate_gb_per_day"`
	CurrentAvgUsage       sql.NullFloat64 `json:"current_avg_usage"`
	EarliestFullDate      interface{}     `json:"earliest_full_date"`
}

func (q *Queries) GetDriveGrowthPrediction(ctx context.Context) ([]GetDriveGrowthPredictionRow, error) {
	rows, err := q.db.QueryContext(ctx, getDriveGrowthPrediction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDriveGrowthPredictionRow
	for rows.Next() {
		var i GetDriveGrowthPredictionRow
		if err := rows.Scan(
			&i.DriveID,
			&i.AvgGrowthRateGbPerDay,
			&i.CurrentAvgUsage,
			&i.EarliestFullDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriveUsageHistory = `-- name: GetDriveUsageHistory :many
SELECT id, drive_id, total_size, used_size, available_size, usage_percentage, growth_rate_gb_per_day, projected_full_date, recorded_at FROM drive_usage_history 
WHERE drive_id = ?1
ORDER BY recorded_at DESC
LIMIT ?2
`

type GetDriveUsageHistoryParams struct {
	DriveID string `json:"drive_id"`
	Limit   int64  `json:"limit"`
}

func (q *Queries) GetDriveUsageHistory(ctx context.Context, arg GetDriveUsageHistoryParams) ([]DriveUsageHistory, error) {
	rows, err := q.db.QueryContext(ctx, getDriveUsageHistory, arg.DriveID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DriveUsageHistory
	for rows.Next() {
		var i DriveUsageHistory
		if err := rows.Scan(
			&i.ID,
			&i.DriveID,
			&i.TotalSize,
			&i.UsedSize,
			&i.AvailableSize,
			&i.UsagePercentage,
			&i.GrowthRateGbPerDay,
			&i.ProjectedFullDate,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestDriveUsage = `-- name: GetLatestDriveUsage :many
SELECT 
    duh.id, duh.drive_id, duh.total_size, duh.used_size, duh.available_size, duh.usage_percentage, duh.growth_rate_gb_per_day, duh.projected_full_date, duh.recorded_at,
    md.name as drive_name,
    md.mount_path as drive_mount_path
FROM drive_usage_history duh
INNER JOIN (
    SELECT drive_id, MAX(recorded_at) as latest_recorded
    FROM drive_usage_history
    GROUP BY drive_id
) latest ON duh.drive_id = latest.drive_id AND duh.recorded_at = latest.latest_recorded
LEFT JOIN mounted_drives md ON duh.drive_id = md.id
ORDER BY duh.usage_percentage DESC
`

type GetLatestDriveUsageRow struct {
	ID                 int64           `json:"id"`
	DriveID            string          `json:"drive_id"`
	TotalSize          int64           `json:"total_size"`
	UsedSize           int64           `json:"used_size"`
	AvailableSize      int64           `json:"available_size"`
	UsagePercentage    float64         `json:"usage_percentage"`
	GrowthRateGbPerDay sql.NullFloat64 `json:"growth_rate_gb_per_day"`
	ProjectedFullDate  sql.NullTime    `json:"projected_full_date"`
	RecordedAt         sql.NullTime    `json:"recorded_at"`
	DriveName          string          `json:"drive_name"`
	DriveMountPath     string          `json:"drive_mount_path"`
}

func (q *Queries) GetLatestDriveUsage(ctx context.Context) ([]GetLatestDriveUsageRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestDriveUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestDriveUsageRow
	for rows.Next() {
		var i GetLatestDriveUsageRow
		if err := rows.Scan(
			&i.ID,
			&i.DriveID,
			&i.TotalSize,
			&i.UsedSize,
			&i.AvailableSize,
			&i.UsagePercentage,
			&i.GrowthRateGbPerDay,
			&i.ProjectedFullDate,
			&i.RecordedAt,
			&i.DriveName,
			&i.DriveMountPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRequestedContent = `-- name: GetMostRequestedContent :many
SELECT 
    tmdb_id,
    media_type,
    title,
    request_count,
    last_requested,
    popularity_score
FROM request_analytics
WHERE last_requested >= datetime('now', '-' || ? || ' days')
ORDER BY request_count DESC
LIMIT ?
`

type GetMostRequestedContentRow struct {
	TmdbID          int64           `json:"tmdb_id"`
	MediaType       string          `json:"media_type"`
	Title           string          `json:"title"`
	RequestCount    sql.NullInt64   `json:"request_count"`
	LastRequested   sql.NullTime    `json:"last_requested"`
	PopularityScore sql.NullFloat64 `json:"popularity_score"`
}

func (q *Queries) GetMostRequestedContent(ctx context.Context, limit int64) ([]GetMostRequestedContentRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostRequestedContent, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostRequestedContentRow
	for rows.Next() {
		var i GetMostRequestedContentRow
		if err := rows.Scan(
			&i.TmdbID,
			&i.MediaType,
			&i.Title,
			&i.RequestCount,
			&i.LastRequested,
			&i.PopularityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentRequestMetrics = `-- name: GetRecentRequestMetrics :many
SELECT id, request_id, status_change, previous_status, new_status, processing_time_seconds, error_code, error_message, user_id, timestamp FROM request_metrics 
WHERE timestamp >= datetime('now', '-' || ? || ' days')
ORDER BY timestamp DESC
LIMIT ?
`

func (q *Queries) GetRecentRequestMetrics(ctx context.Context, limit int64) ([]RequestMetric, error) {
	rows, err := q.db.QueryContext(ctx, getRecentRequestMetrics, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestMetric
	for rows.Next() {
		var i RequestMetric
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.StatusChange,
			&i.PreviousStatus,
			&i.NewStatus,
			&i.ProcessingTimeSeconds,
			&i.ErrorCode,
			&i.ErrorMessage,
			&i.UserID,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestAnalytics = `-- name: GetRequestAnalytics :many
SELECT id, tmdb_id, media_type, title, request_count, last_requested, first_requested, avg_processing_time_seconds, success_rate, popularity_score, created_at, updated_at FROM request_analytics 
ORDER BY popularity_score DESC, request_count DESC
LIMIT ?
`

func (q *Queries) GetRequestAnalytics(ctx context.Context, limit int64) ([]RequestAnalytic, error) {
	rows, err := q.db.QueryContext(ctx, getRequestAnalytics, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestAnalytic
	for rows.Next() {
		var i RequestAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.MediaType,
			&i.Title,
			&i.RequestCount,
			&i.LastRequested,
			&i.FirstRequested,
			&i.AvgProcessingTimeSeconds,
			&i.SuccessRate,
			&i.PopularityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestAnalyticsByMediaType = `-- name: GetRequestAnalyticsByMediaType :many
SELECT id, tmdb_id, media_type, title, request_count, last_requested, first_requested, avg_processing_time_seconds, success_rate, popularity_score, created_at, updated_at FROM request_analytics 
WHERE media_type = ?
ORDER BY popularity_score DESC, request_count DESC
LIMIT ?
`

type GetRequestAnalyticsByMediaTypeParams struct {
	MediaType string `json:"media_type"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetRequestAnalyticsByMediaType(ctx context.Context, arg GetRequestAnalyticsByMediaTypeParams) ([]RequestAnalytic, error) {
	rows, err := q.db.QueryContext(ctx, getRequestAnalyticsByMediaType, arg.MediaType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestAnalytic
	for rows.Next() {
		var i RequestAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.MediaType,
			&i.Title,
			&i.RequestCount,
			&i.LastRequested,
			&i.FirstRequested,
			&i.AvgProcessingTimeSeconds,
			&i.SuccessRate,
			&i.PopularityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestMetricsByRequestID = `-- name: GetRequestMetricsByRequestID :many
SELECT id, request_id, status_change, previous_status, new_status, processing_time_seconds, error_code, error_message, user_id, timestamp FROM request_metrics 
WHERE request_id = ?
ORDER BY timestamp ASC
`

func (q *Queries) GetRequestMetricsByRequestID(ctx context.Context, requestID int64) ([]RequestMetric, error) {
	rows, err := q.db.QueryContext(ctx, getRequestMetricsByRequestID, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestMetric
	for rows.Next() {
		var i RequestMetric
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.StatusChange,
			&i.PreviousStatus,
			&i.NewStatus,
			&i.ProcessingTimeSeconds,
			&i.ErrorCode,
			&i.ErrorMessage,
			&i.UserID,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestSuccessRate = `-- name: GetRequestSuccessRate :one
SELECT 
    COUNT(*) as total_requests,
    SUM(CASE WHEN rm.new_status = 'fulfilled' THEN 1 ELSE 0 END) as fulfilled_requests,
    CAST(SUM(CASE WHEN rm.new_status = 'fulfilled' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) as success_rate
FROM request_metrics rm
WHERE rm.timestamp >= datetime('now', '-' || ? || ' days')
AND rm.status_change = 'created'
`

type GetRequestSuccessRateRow struct {
	TotalRequests     int64           `json:"total_requests"`
	FulfilledRequests sql.NullFloat64 `json:"fulfilled_requests"`
	SuccessRate       int64           `json:"success_rate"`
}

func (q *Queries) GetRequestSuccessRate(ctx context.Context) (GetRequestSuccessRateRow, error) {
	row := q.db.QueryRowContext(ctx, getRequestSuccessRate)
	var i GetRequestSuccessRateRow
	err := row.Scan(&i.TotalRequests, &i.FulfilledRequests, &i.SuccessRate)
	return i, err
}

const getSystemMetrics = `-- name: GetSystemMetrics :many
SELECT id, metric_type, metric_name, metric_value, metadata, recorded_at FROM system_metrics 
WHERE metric_type = ? AND recorded_at >= datetime('now', '-' || ? || ' days')
ORDER BY recorded_at DESC
LIMIT ?
`

type GetSystemMetricsParams struct {
	MetricType string `json:"metric_type"`
	Limit      int64  `json:"limit"`
}

func (q *Queries) GetSystemMetrics(ctx context.Context, arg GetSystemMetricsParams) ([]SystemMetric, error) {
	rows, err := q.db.QueryContext(ctx, getSystemMetrics, arg.MetricType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SystemMetric
	for rows.Next() {
		var i SystemMetric
		if err := rows.Scan(
			&i.ID,
			&i.MetricType,
			&i.MetricName,
			&i.MetricValue,
			&i.Metadata,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingContent = `-- name: GetTrendingContent :many
SELECT id, tmdb_id, media_type, title, trend_source, popularity_score, trend_direction, forecast_confidence, metadata, valid_until, created_at FROM popularity_trends 
WHERE valid_until > CURRENT_TIMESTAMP
ORDER BY popularity_score DESC, forecast_confidence DESC
LIMIT ?
`

func (q *Queries) GetTrendingContent(ctx context.Context, limit int64) ([]PopularityTrend, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingContent, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PopularityTrend
	for rows.Next() {
		var i PopularityTrend
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.MediaType,
			&i.Title,
			&i.TrendSource,
			&i.PopularityScore,
			&i.TrendDirection,
			&i.ForecastConfidence,
			&i.Metadata,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingContentByType = `-- name: GetTrendingContentByType :many
SELECT id, tmdb_id, media_type, title, trend_source, popularity_score, trend_direction, forecast_confidence, metadata, valid_until, created_at FROM popularity_trends 
WHERE media_type = ? AND valid_until > CURRENT_TIMESTAMP
ORDER BY popularity_score DESC, forecast_confidence DESC
LIMIT ?
`

type GetTrendingContentByTypeParams struct {
	MediaType string `json:"media_type"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetTrendingContentByType(ctx context.Context, arg GetTrendingContentByTypeParams) ([]PopularityTrend, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingContentByType, arg.MediaType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PopularityTrend
	for rows.Next() {
		var i PopularityTrend
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.MediaType,
			&i.Title,
			&i.TrendSource,
			&i.PopularityScore,
			&i.TrendDirection,
			&i.ForecastConfidence,
			&i.Metadata,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordDriveUsage = `-- name: RecordDriveUsage :one
INSERT INTO drive_usage_history (drive_id, total_size, used_size, available_size, usage_percentage, growth_rate_gb_per_day, projected_full_date)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, drive_id, total_size, used_size, available_size, usage_percentage, growth_rate_gb_per_day, projected_full_date, recorded_at
`

type RecordDriveUsageParams struct {
	DriveID            string          `json:"drive_id"`
	TotalSize          int64           `json:"total_size"`
	UsedSize           int64           `json:"used_size"`
	AvailableSize      int64           `json:"available_size"`
	UsagePercentage    float64         `json:"usage_percentage"`
	GrowthRateGbPerDay sql.NullFloat64 `json:"growth_rate_gb_per_day"`
	ProjectedFullDate  sql.NullTime    `json:"projected_full_date"`
}

func (q *Queries) RecordDriveUsage(ctx context.Context, arg RecordDriveUsageParams) (DriveUsageHistory, error) {
	row := q.db.QueryRowContext(ctx, recordDriveUsage,
		arg.DriveID,
		arg.TotalSize,
		arg.UsedSize,
		arg.AvailableSize,
		arg.UsagePercentage,
		arg.GrowthRateGbPerDay,
		arg.ProjectedFullDate,
	)
	var i DriveUsageHistory
	err := row.Scan(
		&i.ID,
		&i.DriveID,
		&i.TotalSize,
		&i.UsedSize,
		&i.AvailableSize,
		&i.UsagePercentage,
		&i.GrowthRateGbPerDay,
		&i.ProjectedFullDate,
		&i.RecordedAt,
	)
	return i, err
}

const recordRequestMetric = `-- name: RecordRequestMetric :one
INSERT INTO request_metrics (request_id, status_change, previous_status, new_status, processing_time_seconds, error_code, error_message, user_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, request_id, status_change, previous_status, new_status, processing_time_seconds, error_code, error_message, user_id, timestamp
`

type RecordRequestMetricParams struct {
	RequestID             int64          `json:"request_id"`
	StatusChange          string         `json:"status_change"`
	PreviousStatus        sql.NullString `json:"previous_status"`
	NewStatus             string         `json:"new_status"`
	ProcessingTimeSeconds sql.NullInt64  `json:"processing_time_seconds"`
	ErrorCode             sql.NullInt64  `json:"error_code"`
	ErrorMessage          sql.NullString `json:"error_message"`
	UserID                string         `json:"user_id"`
}

func (q *Queries) RecordRequestMetric(ctx context.Context, arg RecordRequestMetricParams) (RequestMetric, error) {
	row := q.db.QueryRowContext(ctx, recordRequestMetric,
		arg.RequestID,
		arg.StatusChange,
		arg.PreviousStatus,
		arg.NewStatus,
		arg.ProcessingTimeSeconds,
		arg.ErrorCode,
		arg.ErrorMessage,
		arg.UserID,
	)
	var i RequestMetric
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.StatusChange,
		&i.PreviousStatus,
		&i.NewStatus,
		&i.ProcessingTimeSeconds,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.UserID,
		&i.Timestamp,
	)
	return i, err
}

const recordSystemMetric = `-- name: RecordSystemMetric :one
INSERT INTO system_metrics (metric_type, metric_name, metric_value, metadata)
VALUES (?, ?, ?, ?)
RETURNING id, metric_type, metric_name, metric_value, metadata, recorded_at
`

type RecordSystemMetricParams struct {
	MetricType  string         `json:"metric_type"`
	MetricName  string         `json:"metric_name"`
	MetricValue float64        `json:"metric_value"`
	Metadata    sql.NullString `json:"metadata"`
}

func (q *Queries) RecordSystemMetric(ctx context.Context, arg RecordSystemMetricParams) (SystemMetric, error) {
	row := q.db.QueryRowContext(ctx, recordSystemMetric,
		arg.MetricType,
		arg.MetricName,
		arg.MetricValue,
		arg.Metadata,
	)
	var i SystemMetric
	err := row.Scan(
		&i.ID,
		&i.MetricType,
		&i.MetricName,
		&i.MetricValue,
		&i.Metadata,
		&i.RecordedAt,
	)
	return i, err
}

const upsertPopularityTrend = `-- name: UpsertPopularityTrend :one
INSERT INTO popularity_trends (tmdb_id, media_type, title, trend_source, popularity_score, trend_direction, forecast_confidence, metadata, valid_until)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(tmdb_id, media_type, trend_source) DO UPDATE SET
    title = ?,
    popularity_score = ?,
    trend_direction = ?,
    forecast_confidence = ?,
    metadata = ?,
    valid_until = ?,
    created_at = CURRENT_TIMESTAMP
RETURNING id, tmdb_id, media_type, title, trend_source, popularity_score, trend_direction, forecast_confidence, metadata, valid_until, created_at
`

type UpsertPopularityTrendParams struct {
	TmdbID             int64           `json:"tmdb_id"`
	MediaType          string          `json:"media_type"`
	Title              string          `json:"title"`
	TrendSource        string          `json:"trend_source"`
	PopularityScore    float64         `json:"popularity_score"`
	TrendDirection     sql.NullString  `json:"trend_direction"`
	ForecastConfidence sql.NullFloat64 `json:"forecast_confidence"`
	Metadata           sql.NullString  `json:"metadata"`
	ValidUntil         sql.NullTime    `json:"valid_until"`
}

func (q *Queries) UpsertPopularityTrend(ctx context.Context, arg UpsertPopularityTrendParams) (PopularityTrend, error) {
	row := q.db.QueryRowContext(ctx, upsertPopularityTrend,
		arg.TmdbID,
		arg.MediaType,
		arg.Title,
		arg.TrendSource,
		arg.PopularityScore,
		arg.TrendDirection,
		arg.ForecastConfidence,
		arg.Metadata,
		arg.ValidUntil,
	)
	var i PopularityTrend
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.MediaType,
		&i.Title,
		&i.TrendSource,
		&i.PopularityScore,
		&i.TrendDirection,
		&i.ForecastConfidence,
		&i.Metadata,
		&i.ValidUntil,
		&i.CreatedAt,
	)
	return i, err
}

const upsertRequestAnalytics = `-- name: UpsertRequestAnalytics :one
INSERT INTO request_analytics (tmdb_id, media_type, title, request_count, last_requested, first_requested, avg_processing_time_seconds, success_rate, popularity_score)
VALUES (?, ?, ?, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?, ?)
ON CONFLICT(tmdb_id, media_type) DO UPDATE SET
    request_count = request_count + 1,
    last_requested = CURRENT_TIMESTAMP,
    avg_processing_time_seconds = (avg_processing_time_seconds * (request_count - 1) + ?) / request_count,
    success_rate = ?,
    popularity_score = ?,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, tmdb_id, media_type, title, request_count, last_requested, first_requested, avg_processing_time_seconds, success_rate, popularity_score, created_at, updated_at
`

type UpsertRequestAnalyticsParams struct {
	TmdbID                   int64           `json:"tmdb_id"`
	MediaType                string          `json:"media_type"`
	Title                    string          `json:"title"`
	AvgProcessingTimeSeconds sql.NullInt64   `json:"avg_processing_time_seconds"`
	SuccessRate              sql.NullFloat64 `json:"success_rate"`
	PopularityScore          sql.NullFloat64 `json:"popularity_score"`
}

func (q *Queries) UpsertRequestAnalytics(ctx context.Context, arg UpsertRequestAnalyticsParams) (RequestAnalytic, error) {
	row := q.db.QueryRowContext(ctx, upsertRequestAnalytics,
		arg.TmdbID,
		arg.MediaType,
		arg.Title,
		arg.AvgProcessingTimeSeconds,
		arg.SuccessRate,
		arg.PopularityScore,
	)
	var i RequestAnalytic
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.MediaType,
		&i.Title,
		&i.RequestCount,
		&i.LastRequested,
		&i.FirstRequested,
		&i.AvgProcessingTimeSeconds,
		&i.SuccessRate,
		&i.PopularityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
