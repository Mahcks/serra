// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: request_analytics.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const getContentAvailabilityVsRequests = `-- name: GetContentAvailabilityVsRequests :many
SELECT 
    r.tmdb_id,
    r.title,
    r.media_type,
    COUNT(r.id) as request_count,
    MAX(r.created_at) as last_requested,
    -- Check if content exists in library (basic availability check)
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM library_items li 
            WHERE li.tmdb_id = CAST(r.tmdb_id AS TEXT)
            AND (
                (r.media_type = 'movie' AND li.type = 'Movie') OR
                (r.media_type = 'tv' AND li.type IN ('Series', 'Season', 'Episode'))
            )
        ) THEN 1 
        ELSE 0 
    END as is_available,
    COUNT(CASE WHEN r.status IN ('approved', 'completed') THEN 1 END) as fulfilled_requests
FROM requests r
WHERE r.created_at >= ?
GROUP BY r.tmdb_id, r.title, r.media_type
ORDER BY COUNT(r.id) DESC, MAX(r.created_at) DESC
LIMIT ?
`

type GetContentAvailabilityVsRequestsParams struct {
	CreatedAt time.Time `json:"created_at"`
	Limit     int64     `json:"limit"`
}

type GetContentAvailabilityVsRequestsRow struct {
	TmdbID            sql.NullInt64  `json:"tmdb_id"`
	Title             sql.NullString `json:"title"`
	MediaType         string         `json:"media_type"`
	RequestCount      int64          `json:"request_count"`
	LastRequested     interface{}    `json:"last_requested"`
	IsAvailable       interface{}    `json:"is_available"`
	FulfilledRequests int64          `json:"fulfilled_requests"`
}

// GetContentAvailabilityVsRequests returns content popularity vs current availability
func (q *Queries) GetContentAvailabilityVsRequests(ctx context.Context, arg GetContentAvailabilityVsRequestsParams) ([]GetContentAvailabilityVsRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentAvailabilityVsRequests, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContentAvailabilityVsRequestsRow
	for rows.Next() {
		var i GetContentAvailabilityVsRequestsRow
		if err := rows.Scan(
			&i.TmdbID,
			&i.Title,
			&i.MediaType,
			&i.RequestCount,
			&i.LastRequested,
			&i.IsAvailable,
			&i.FulfilledRequests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailureAnalysis = `-- name: GetFailureAnalysis :many
SELECT 
    media_type,
    COUNT(*) as total_failures,
    -- Extract common failure reasons from notes if available
    COUNT(CASE WHEN notes LIKE '%not found%' OR notes LIKE '%404%' THEN 1 END) as not_found_failures,
    COUNT(CASE WHEN notes LIKE '%timeout%' OR notes LIKE '%connection%' THEN 1 END) as connection_failures,
    COUNT(CASE WHEN notes LIKE '%quality%' OR notes LIKE '%profile%' THEN 1 END) as quality_failures,
    COUNT(CASE WHEN notes LIKE '%space%' OR notes LIKE '%disk%' THEN 1 END) as storage_failures
FROM requests 
WHERE status = 'failed' 
AND created_at >= ?
GROUP BY media_type
ORDER BY COUNT(*) DESC
`

type GetFailureAnalysisRow struct {
	MediaType          string `json:"media_type"`
	TotalFailures      int64  `json:"total_failures"`
	NotFoundFailures   int64  `json:"not_found_failures"`
	ConnectionFailures int64  `json:"connection_failures"`
	QualityFailures    int64  `json:"quality_failures"`
	StorageFailures    int64  `json:"storage_failures"`
}

// GetFailureAnalysis returns analysis of failed requests
func (q *Queries) GetFailureAnalysis(ctx context.Context, createdAt time.Time) ([]GetFailureAnalysisRow, error) {
	rows, err := q.db.QueryContext(ctx, getFailureAnalysis, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFailureAnalysisRow
	for rows.Next() {
		var i GetFailureAnalysisRow
		if err := rows.Scan(
			&i.MediaType,
			&i.TotalFailures,
			&i.NotFoundFailures,
			&i.ConnectionFailures,
			&i.QualityFailures,
			&i.StorageFailures,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularRequestedContent = `-- name: GetPopularRequestedContent :many
SELECT 
    tmdb_id,
    title,
    media_type,
    COUNT(*) as request_count,
    COUNT(CASE WHEN status IN ('approved', 'completed') THEN 1 END) as fulfilled_count,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_count,
    ROUND(COUNT(CASE WHEN status IN ('approved', 'completed') THEN 1 END) * 100.0 / COUNT(*), 2) as fulfillment_rate,
    MIN(created_at) as first_requested,
    MAX(created_at) as last_requested
FROM requests 
WHERE created_at >= ?
GROUP BY tmdb_id, title, media_type
HAVING COUNT(*) > 1
ORDER BY COUNT(*) DESC, COUNT(CASE WHEN status IN ('approved', 'completed') THEN 1 END) DESC
LIMIT ?
`

type GetPopularRequestedContentParams struct {
	CreatedAt time.Time `json:"created_at"`
	Limit     int64     `json:"limit"`
}

type GetPopularRequestedContentRow struct {
	TmdbID          sql.NullInt64  `json:"tmdb_id"`
	Title           sql.NullString `json:"title"`
	MediaType       string         `json:"media_type"`
	RequestCount    int64          `json:"request_count"`
	FulfilledCount  int64          `json:"fulfilled_count"`
	FailedCount     int64          `json:"failed_count"`
	FulfillmentRate float64        `json:"fulfillment_rate"`
	FirstRequested  interface{}    `json:"first_requested"`
	LastRequested   interface{}    `json:"last_requested"`
}

// GetPopularRequestedContent returns most requested content with fulfillment status
func (q *Queries) GetPopularRequestedContent(ctx context.Context, arg GetPopularRequestedContentParams) ([]GetPopularRequestedContentRow, error) {
	rows, err := q.db.QueryContext(ctx, getPopularRequestedContent, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPopularRequestedContentRow
	for rows.Next() {
		var i GetPopularRequestedContentRow
		if err := rows.Scan(
			&i.TmdbID,
			&i.Title,
			&i.MediaType,
			&i.RequestCount,
			&i.FulfilledCount,
			&i.FailedCount,
			&i.FulfillmentRate,
			&i.FirstRequested,
			&i.LastRequested,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestFulfillmentByUser = `-- name: GetRequestFulfillmentByUser :many
SELECT 
    u.username,
    COUNT(*) as total_requests,
    COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_requests,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_requests,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_requests,
    ROUND(COUNT(CASE WHEN status IN ('approved', 'completed') THEN 1 END) * 100.0 / COUNT(*), 2) as success_rate
FROM requests r
JOIN users u ON r.user_id = u.id
WHERE r.created_at >= ?
GROUP BY u.id, u.username
ORDER BY COUNT(*) DESC
LIMIT ?
`

type GetRequestFulfillmentByUserParams struct {
	CreatedAt time.Time `json:"created_at"`
	Limit     int64     `json:"limit"`
}

type GetRequestFulfillmentByUserRow struct {
	Username          string  `json:"username"`
	TotalRequests     int64   `json:"total_requests"`
	ApprovedRequests  int64   `json:"approved_requests"`
	CompletedRequests int64   `json:"completed_requests"`
	FailedRequests    int64   `json:"failed_requests"`
	SuccessRate       float64 `json:"success_rate"`
}

// GetRequestFulfillmentByUser returns request fulfillment metrics per user
func (q *Queries) GetRequestFulfillmentByUser(ctx context.Context, arg GetRequestFulfillmentByUserParams) ([]GetRequestFulfillmentByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestFulfillmentByUser, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestFulfillmentByUserRow
	for rows.Next() {
		var i GetRequestFulfillmentByUserRow
		if err := rows.Scan(
			&i.Username,
			&i.TotalRequests,
			&i.ApprovedRequests,
			&i.CompletedRequests,
			&i.FailedRequests,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestProcessingPerformance = `-- name: GetRequestProcessingPerformance :many
SELECT 
    media_type,
    status,
    COUNT(*) as count
FROM requests 
WHERE created_at >= ?
GROUP BY media_type, status
ORDER BY media_type, count DESC
`

type GetRequestProcessingPerformanceRow struct {
	MediaType string `json:"media_type"`
	Status    string `json:"status"`
	Count     int64  `json:"count"`
}

// GetRequestProcessingPerformance returns processing performance metrics (simplified)
func (q *Queries) GetRequestProcessingPerformance(ctx context.Context, createdAt time.Time) ([]GetRequestProcessingPerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestProcessingPerformance, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestProcessingPerformanceRow
	for rows.Next() {
		var i GetRequestProcessingPerformanceRow
		if err := rows.Scan(&i.MediaType, &i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestSuccessRates = `-- name: GetRequestSuccessRates :many

SELECT 
    status,
    COUNT(*) as total_requests,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage
FROM requests 
WHERE created_at >= ?
GROUP BY status
ORDER BY COUNT(*) DESC
`

type GetRequestSuccessRatesRow struct {
	Status        string  `json:"status"`
	TotalRequests int64   `json:"total_requests"`
	Percentage    float64 `json:"percentage"`
}

// Request/Fulfillment Analytics Queries
// GetRequestSuccessRates returns success rates by status and time period
func (q *Queries) GetRequestSuccessRates(ctx context.Context, createdAt time.Time) ([]GetRequestSuccessRatesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestSuccessRates, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestSuccessRatesRow
	for rows.Next() {
		var i GetRequestSuccessRatesRow
		if err := rows.Scan(&i.Status, &i.TotalRequests, &i.Percentage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestTrends = `-- name: GetRequestTrends :many
SELECT 
    DATE(created_at) as request_date,
    COUNT(*) as total_requests,
    COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_requests,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_requests,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_requests,
    COUNT(CASE WHEN media_type = 'movie' THEN 1 END) as movie_requests,
    COUNT(CASE WHEN media_type = 'tv' THEN 1 END) as tv_requests
FROM requests 
WHERE created_at >= ?
GROUP BY DATE(created_at)
ORDER BY request_date DESC
LIMIT ?
`

type GetRequestTrendsParams struct {
	CreatedAt time.Time `json:"created_at"`
	Limit     int64     `json:"limit"`
}

type GetRequestTrendsRow struct {
	RequestDate       interface{} `json:"request_date"`
	TotalRequests     int64       `json:"total_requests"`
	ApprovedRequests  int64       `json:"approved_requests"`
	CompletedRequests int64       `json:"completed_requests"`
	FailedRequests    int64       `json:"failed_requests"`
	MovieRequests     int64       `json:"movie_requests"`
	TvRequests        int64       `json:"tv_requests"`
}

// GetRequestTrends returns request trends over time periods
func (q *Queries) GetRequestTrends(ctx context.Context, arg GetRequestTrendsParams) ([]GetRequestTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestTrends, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestTrendsRow
	for rows.Next() {
		var i GetRequestTrendsRow
		if err := rows.Scan(
			&i.RequestDate,
			&i.TotalRequests,
			&i.ApprovedRequests,
			&i.CompletedRequests,
			&i.FailedRequests,
			&i.MovieRequests,
			&i.TvRequests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestVolumeByHour = `-- name: GetRequestVolumeByHour :many
SELECT 
    CAST(strftime('%H', created_at) AS INTEGER) as hour_of_day,
    COUNT(*) as total_requests,
    COUNT(CASE WHEN status IN ('approved', 'completed') THEN 1 END) as successful_requests,
    ROUND(COUNT(CASE WHEN status IN ('approved', 'completed') THEN 1 END) * 100.0 / COUNT(*), 2) as success_rate
FROM requests 
WHERE created_at >= ?
GROUP BY CAST(strftime('%H', created_at) AS INTEGER)
ORDER BY hour_of_day
`

type GetRequestVolumeByHourRow struct {
	HourOfDay          interface{} `json:"hour_of_day"`
	TotalRequests      int64       `json:"total_requests"`
	SuccessfulRequests int64       `json:"successful_requests"`
	SuccessRate        float64     `json:"success_rate"`
}

// GetRequestVolumeByHour returns request volume patterns by hour of day
func (q *Queries) GetRequestVolumeByHour(ctx context.Context, createdAt time.Time) ([]GetRequestVolumeByHourRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestVolumeByHour, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestVolumeByHourRow
	for rows.Next() {
		var i GetRequestVolumeByHourRow
		if err := rows.Scan(
			&i.HourOfDay,
			&i.TotalRequests,
			&i.SuccessfulRequests,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
