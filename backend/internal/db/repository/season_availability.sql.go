// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: season_availability.sql

package repository

import (
	"context"
	"database/sql"
)

const getSeasonAvailabilityByTMDBID = `-- name: GetSeasonAvailabilityByTMDBID :many
SELECT id, tmdb_id, season_number, episode_count, available_episodes, is_complete, last_updated
FROM season_availability
WHERE tmdb_id = ?
ORDER BY season_number
`

func (q *Queries) GetSeasonAvailabilityByTMDBID(ctx context.Context, tmdbID int64) ([]SeasonAvailability, error) {
	rows, err := q.db.QueryContext(ctx, getSeasonAvailabilityByTMDBID, tmdbID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SeasonAvailability
	for rows.Next() {
		var i SeasonAvailability
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.SeasonNumber,
			&i.EpisodeCount,
			&i.AvailableEpisodes,
			&i.IsComplete,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonAvailabilityByTMDBIDAndSeason = `-- name: GetSeasonAvailabilityByTMDBIDAndSeason :one
SELECT id, tmdb_id, season_number, episode_count, available_episodes, is_complete, last_updated
FROM season_availability
WHERE tmdb_id = ? AND season_number = ?
`

type GetSeasonAvailabilityByTMDBIDAndSeasonParams struct {
	TmdbID       int64
	SeasonNumber int64
}

func (q *Queries) GetSeasonAvailabilityByTMDBIDAndSeason(ctx context.Context, arg GetSeasonAvailabilityByTMDBIDAndSeasonParams) (SeasonAvailability, error) {
	row := q.db.QueryRowContext(ctx, getSeasonAvailabilityByTMDBIDAndSeason, arg.TmdbID, arg.SeasonNumber)
	var i SeasonAvailability
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.SeasonNumber,
		&i.EpisodeCount,
		&i.AvailableEpisodes,
		&i.IsComplete,
		&i.LastUpdated,
	)
	return i, err
}

const updateSeasonAvailableEpisodes = `-- name: UpdateSeasonAvailableEpisodes :exec
INSERT INTO season_availability (tmdb_id, season_number, episode_count, available_episodes, last_updated)
VALUES (?, ?, 0, ?, CURRENT_TIMESTAMP)
ON CONFLICT(tmdb_id, season_number) DO UPDATE SET
    available_episodes = excluded.available_episodes,
    is_complete = (excluded.available_episodes >= season_availability.episode_count AND season_availability.episode_count > 0),
    last_updated = CURRENT_TIMESTAMP
`

type UpdateSeasonAvailableEpisodesParams struct {
	TmdbID            int64
	SeasonNumber      int64
	AvailableEpisodes sql.NullInt64
}

func (q *Queries) UpdateSeasonAvailableEpisodes(ctx context.Context, arg UpdateSeasonAvailableEpisodesParams) error {
	_, err := q.db.ExecContext(ctx, updateSeasonAvailableEpisodes, arg.TmdbID, arg.SeasonNumber, arg.AvailableEpisodes)
	return err
}

const upsertSeasonAvailability = `-- name: UpsertSeasonAvailability :exec
INSERT INTO season_availability (tmdb_id, season_number, episode_count, available_episodes, is_complete, last_updated)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(tmdb_id, season_number) DO UPDATE SET
    episode_count = excluded.episode_count,
    available_episodes = excluded.available_episodes,
    is_complete = excluded.is_complete,
    last_updated = CURRENT_TIMESTAMP
`

type UpsertSeasonAvailabilityParams struct {
	TmdbID            int64
	SeasonNumber      int64
	EpisodeCount      int64
	AvailableEpisodes sql.NullInt64
	IsComplete        sql.NullBool
}

func (q *Queries) UpsertSeasonAvailability(ctx context.Context, arg UpsertSeasonAvailabilityParams) error {
	_, err := q.db.ExecContext(ctx, upsertSeasonAvailability,
		arg.TmdbID,
		arg.SeasonNumber,
		arg.EpisodeCount,
		arg.AvailableEpisodes,
		arg.IsComplete,
	)
	return err
}
