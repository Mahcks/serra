// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: user_notification_preferences.sql

package repository

import (
	"context"
	"database/sql"
)

const checkUserNotificationEnabled = `-- name: CheckUserNotificationEnabled :one
SELECT 
    CASE 
        WHEN ? = 'request_approved' THEN requests_approved
        WHEN ? = 'request_denied' THEN requests_denied
        WHEN ? = 'download_completed' THEN download_completed
        WHEN ? = 'media_available' THEN media_available
        WHEN ? = 'system_alert' THEN system_alerts
        ELSE TRUE
    END as enabled,
    web_notifications,
    min_priority,
    quiet_hours_enabled,
    quiet_hours_start,
    quiet_hours_end
FROM user_notification_preferences 
WHERE user_id = ?
`

type CheckUserNotificationEnabledRow struct {
	Enabled           interface{}    `json:"enabled"`
	WebNotifications  sql.NullBool   `json:"web_notifications"`
	MinPriority       sql.NullString `json:"min_priority"`
	QuietHoursEnabled sql.NullBool   `json:"quiet_hours_enabled"`
	QuietHoursStart   interface{}    `json:"quiet_hours_start"`
	QuietHoursEnd     interface{}    `json:"quiet_hours_end"`
}

func (q *Queries) CheckUserNotificationEnabled(ctx context.Context, userID string) (CheckUserNotificationEnabledRow, error) {
	row := q.db.QueryRowContext(ctx, checkUserNotificationEnabled, userID)
	var i CheckUserNotificationEnabledRow
	err := row.Scan(
		&i.Enabled,
		&i.WebNotifications,
		&i.MinPriority,
		&i.QuietHoursEnabled,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
	)
	return i, err
}

const createDefaultUserNotificationPreferences = `-- name: CreateDefaultUserNotificationPreferences :exec
INSERT INTO user_notification_preferences (id, user_id)
VALUES (?, ?)
ON CONFLICT(user_id) DO NOTHING
`

type CreateDefaultUserNotificationPreferencesParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) CreateDefaultUserNotificationPreferences(ctx context.Context, arg CreateDefaultUserNotificationPreferencesParams) error {
	_, err := q.db.ExecContext(ctx, createDefaultUserNotificationPreferences, arg.ID, arg.UserID)
	return err
}

const createUserNotificationPreferences = `-- name: CreateUserNotificationPreferences :exec
INSERT INTO user_notification_preferences (
    id, user_id, requests_approved, requests_denied, download_completed, media_available, system_alerts,
    min_priority, web_notifications, email_notifications, push_notifications,
    quiet_hours_enabled, quiet_hours_start, quiet_hours_end, auto_mark_read_after_days
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateUserNotificationPreferencesParams struct {
	ID                    string         `json:"id"`
	UserID                string         `json:"user_id"`
	RequestsApproved      sql.NullBool   `json:"requests_approved"`
	RequestsDenied        sql.NullBool   `json:"requests_denied"`
	DownloadCompleted     sql.NullBool   `json:"download_completed"`
	MediaAvailable        sql.NullBool   `json:"media_available"`
	SystemAlerts          sql.NullBool   `json:"system_alerts"`
	MinPriority           sql.NullString `json:"min_priority"`
	WebNotifications      sql.NullBool   `json:"web_notifications"`
	EmailNotifications    sql.NullBool   `json:"email_notifications"`
	PushNotifications     sql.NullBool   `json:"push_notifications"`
	QuietHoursEnabled     sql.NullBool   `json:"quiet_hours_enabled"`
	QuietHoursStart       interface{}    `json:"quiet_hours_start"`
	QuietHoursEnd         interface{}    `json:"quiet_hours_end"`
	AutoMarkReadAfterDays sql.NullInt64  `json:"auto_mark_read_after_days"`
}

func (q *Queries) CreateUserNotificationPreferences(ctx context.Context, arg CreateUserNotificationPreferencesParams) error {
	_, err := q.db.ExecContext(ctx, createUserNotificationPreferences,
		arg.ID,
		arg.UserID,
		arg.RequestsApproved,
		arg.RequestsDenied,
		arg.DownloadCompleted,
		arg.MediaAvailable,
		arg.SystemAlerts,
		arg.MinPriority,
		arg.WebNotifications,
		arg.EmailNotifications,
		arg.PushNotifications,
		arg.QuietHoursEnabled,
		arg.QuietHoursStart,
		arg.QuietHoursEnd,
		arg.AutoMarkReadAfterDays,
	)
	return err
}

const deleteUserNotificationPreferences = `-- name: DeleteUserNotificationPreferences :exec
DELETE FROM user_notification_preferences 
WHERE user_id = ?
`

func (q *Queries) DeleteUserNotificationPreferences(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserNotificationPreferences, userID)
	return err
}

const getUserNotificationPreferences = `-- name: GetUserNotificationPreferences :one
SELECT 
    id, user_id, requests_approved, requests_denied, download_completed, media_available, system_alerts,
    min_priority, web_notifications, email_notifications, push_notifications,
    quiet_hours_enabled, quiet_hours_start, quiet_hours_end, auto_mark_read_after_days,
    created_at, updated_at
FROM user_notification_preferences 
WHERE user_id = ?
`

func (q *Queries) GetUserNotificationPreferences(ctx context.Context, userID string) (UserNotificationPreference, error) {
	row := q.db.QueryRowContext(ctx, getUserNotificationPreferences, userID)
	var i UserNotificationPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RequestsApproved,
		&i.RequestsDenied,
		&i.DownloadCompleted,
		&i.MediaAvailable,
		&i.SystemAlerts,
		&i.MinPriority,
		&i.WebNotifications,
		&i.EmailNotifications,
		&i.PushNotifications,
		&i.QuietHoursEnabled,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
		&i.AutoMarkReadAfterDays,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsersForQuietHoursCleanup = `-- name: GetUsersForQuietHoursCleanup :many
SELECT user_id, auto_mark_read_after_days
FROM user_notification_preferences
WHERE auto_mark_read_after_days IS NOT NULL
    AND auto_mark_read_after_days > 0
`

type GetUsersForQuietHoursCleanupRow struct {
	UserID                string        `json:"user_id"`
	AutoMarkReadAfterDays sql.NullInt64 `json:"auto_mark_read_after_days"`
}

func (q *Queries) GetUsersForQuietHoursCleanup(ctx context.Context) ([]GetUsersForQuietHoursCleanupRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersForQuietHoursCleanup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersForQuietHoursCleanupRow
	for rows.Next() {
		var i GetUsersForQuietHoursCleanupRow
		if err := rows.Scan(&i.UserID, &i.AutoMarkReadAfterDays); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithNotificationPreference = `-- name: GetUsersWithNotificationPreference :many
SELECT DISTINCT user_id
FROM user_notification_preferences
WHERE 
    CASE 
        WHEN ? = 'request_approved' THEN requests_approved = TRUE
        WHEN ? = 'request_denied' THEN requests_denied = TRUE
        WHEN ? = 'download_completed' THEN download_completed = TRUE
        WHEN ? = 'media_available' THEN media_available = TRUE
        WHEN ? = 'system_alert' THEN system_alerts = TRUE
        ELSE TRUE
    END
    AND web_notifications = TRUE
`

func (q *Queries) GetUsersWithNotificationPreference(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithNotificationPreference)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserNotificationPreferences = `-- name: UpdateUserNotificationPreferences :exec
UPDATE user_notification_preferences SET
    requests_approved = ?,
    requests_denied = ?,
    download_completed = ?,
    media_available = ?,
    system_alerts = ?,
    min_priority = ?,
    web_notifications = ?,
    email_notifications = ?,
    push_notifications = ?,
    quiet_hours_enabled = ?,
    quiet_hours_start = ?,
    quiet_hours_end = ?,
    auto_mark_read_after_days = ?
WHERE user_id = ?
`

type UpdateUserNotificationPreferencesParams struct {
	RequestsApproved      sql.NullBool   `json:"requests_approved"`
	RequestsDenied        sql.NullBool   `json:"requests_denied"`
	DownloadCompleted     sql.NullBool   `json:"download_completed"`
	MediaAvailable        sql.NullBool   `json:"media_available"`
	SystemAlerts          sql.NullBool   `json:"system_alerts"`
	MinPriority           sql.NullString `json:"min_priority"`
	WebNotifications      sql.NullBool   `json:"web_notifications"`
	EmailNotifications    sql.NullBool   `json:"email_notifications"`
	PushNotifications     sql.NullBool   `json:"push_notifications"`
	QuietHoursEnabled     sql.NullBool   `json:"quiet_hours_enabled"`
	QuietHoursStart       interface{}    `json:"quiet_hours_start"`
	QuietHoursEnd         interface{}    `json:"quiet_hours_end"`
	AutoMarkReadAfterDays sql.NullInt64  `json:"auto_mark_read_after_days"`
	UserID                string         `json:"user_id"`
}

func (q *Queries) UpdateUserNotificationPreferences(ctx context.Context, arg UpdateUserNotificationPreferencesParams) error {
	_, err := q.db.ExecContext(ctx, updateUserNotificationPreferences,
		arg.RequestsApproved,
		arg.RequestsDenied,
		arg.DownloadCompleted,
		arg.MediaAvailable,
		arg.SystemAlerts,
		arg.MinPriority,
		arg.WebNotifications,
		arg.EmailNotifications,
		arg.PushNotifications,
		arg.QuietHoursEnabled,
		arg.QuietHoursStart,
		arg.QuietHoursEnd,
		arg.AutoMarkReadAfterDays,
		arg.UserID,
	)
	return err
}
