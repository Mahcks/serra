// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: downloads.sql

package repository

import (
	"context"
	"database/sql"
)

const deleteDownload = `-- name: DeleteDownload :exec
DELETE FROM downloads WHERE id = ?
`

func (q *Queries) DeleteDownload(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteDownload, id)
	return err
}

const getOldMissingDownloads = `-- name: GetOldMissingDownloads :many
SELECT
  id,
  title,
  torrent_title,
  source,
  tmdb_id,
  tvdb_id,
  hash,
  progress,
  time_left,
  status,
  last_updated
FROM downloads
WHERE status = 'missing_from_client'
  AND last_updated < datetime('now', '-24 hours')
ORDER BY last_updated ASC
`

type GetOldMissingDownloadsRow struct {
	ID           string          `json:"id"`
	Title        string          `json:"title"`
	TorrentTitle string          `json:"torrent_title"`
	Source       string          `json:"source"`
	TmdbID       sql.NullInt64   `json:"tmdb_id"`
	TvdbID       sql.NullInt64   `json:"tvdb_id"`
	Hash         sql.NullString  `json:"hash"`
	Progress     sql.NullFloat64 `json:"progress"`
	TimeLeft     sql.NullString  `json:"time_left"`
	Status       sql.NullString  `json:"status"`
	LastUpdated  sql.NullTime    `json:"last_updated"`
}

func (q *Queries) GetOldMissingDownloads(ctx context.Context) ([]GetOldMissingDownloadsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOldMissingDownloads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOldMissingDownloadsRow
	for rows.Next() {
		var i GetOldMissingDownloadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TorrentTitle,
			&i.Source,
			&i.TmdbID,
			&i.TvdbID,
			&i.Hash,
			&i.Progress,
			&i.TimeLeft,
			&i.Status,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloads = `-- name: ListDownloads :many
SELECT
  id,
  title,
  torrent_title,
  source,
  tmdb_id,
  tvdb_id,
  hash,
  progress,
  time_left,
  status,
  last_updated
FROM downloads
WHERE status IS NULL OR status != 'completed'
ORDER BY last_updated DESC
`

type ListDownloadsRow struct {
	ID           string          `json:"id"`
	Title        string          `json:"title"`
	TorrentTitle string          `json:"torrent_title"`
	Source       string          `json:"source"`
	TmdbID       sql.NullInt64   `json:"tmdb_id"`
	TvdbID       sql.NullInt64   `json:"tvdb_id"`
	Hash         sql.NullString  `json:"hash"`
	Progress     sql.NullFloat64 `json:"progress"`
	TimeLeft     sql.NullString  `json:"time_left"`
	Status       sql.NullString  `json:"status"`
	LastUpdated  sql.NullTime    `json:"last_updated"`
}

func (q *Queries) ListDownloads(ctx context.Context) ([]ListDownloadsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDownloads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDownloadsRow
	for rows.Next() {
		var i ListDownloadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TorrentTitle,
			&i.Source,
			&i.TmdbID,
			&i.TvdbID,
			&i.Hash,
			&i.Progress,
			&i.TimeLeft,
			&i.Status,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadsBySource = `-- name: ListDownloadsBySource :many
SELECT id, title, torrent_title, source, tmdb_id, tvdb_id, hash, progress, time_left, status, last_updated, download_speed, upload_speed, download_size FROM downloads WHERE source = ?
`

func (q *Queries) ListDownloadsBySource(ctx context.Context, source string) ([]Download, error) {
	rows, err := q.db.QueryContext(ctx, listDownloadsBySource, source)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Download
	for rows.Next() {
		var i Download
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TorrentTitle,
			&i.Source,
			&i.TmdbID,
			&i.TvdbID,
			&i.Hash,
			&i.Progress,
			&i.TimeLeft,
			&i.Status,
			&i.LastUpdated,
			&i.DownloadSpeed,
			&i.UploadSpeed,
			&i.DownloadSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDownloadQueue = `-- name: UpsertDownloadQueue :exec
INSERT INTO downloads (
  id, title, torrent_title, source, tmdb_id, tvdb_id, hash, progress, time_left, status, last_updated
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP
)
ON CONFLICT(id) DO UPDATE SET
  title = excluded.title,
  torrent_title = excluded.torrent_title,
  source = excluded.source,
  tmdb_id = excluded.tmdb_id,
  tvdb_id = excluded.tvdb_id,
  hash = excluded.hash,
  progress = excluded.progress,
  time_left = excluded.time_left,
  status = excluded.status,
  last_updated = CURRENT_TIMESTAMP
`

type UpsertDownloadQueueParams struct {
	ID           string          `json:"id"`
	Title        string          `json:"title"`
	TorrentTitle string          `json:"torrent_title"`
	Source       string          `json:"source"`
	TmdbID       sql.NullInt64   `json:"tmdb_id"`
	TvdbID       sql.NullInt64   `json:"tvdb_id"`
	Hash         sql.NullString  `json:"hash"`
	Progress     sql.NullFloat64 `json:"progress"`
	TimeLeft     sql.NullString  `json:"time_left"`
	Status       sql.NullString  `json:"status"`
}

func (q *Queries) UpsertDownloadQueue(ctx context.Context, arg UpsertDownloadQueueParams) error {
	_, err := q.db.ExecContext(ctx, upsertDownloadQueue,
		arg.ID,
		arg.Title,
		arg.TorrentTitle,
		arg.Source,
		arg.TmdbID,
		arg.TvdbID,
		arg.Hash,
		arg.Progress,
		arg.TimeLeft,
		arg.Status,
	)
	return err
}
